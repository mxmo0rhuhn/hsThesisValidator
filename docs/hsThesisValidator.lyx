#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{url}
\lhead{\bfseries Softwareprojekt 2}
\chead{}
\rhead{ Gültigkeit und Beweisbarkeit in einer\\mathematischen Theorie}
\lfoot{Reto Hablützel\\Max Schrimpf }
\cfoot{ZHAW\\FS 2013}
\rfoot{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\lstset{
frame=single, 
numbers=left,
 breaklines=true,  
basicstyle=\footnotesize\ttfamily, 
numbersep=5pt,
float=h
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language german-ch
\language_package auto
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 2cm
\headsep 1cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language polish
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\bullet 0 0 0 -1
\bullet 1 0 8 -1
\bullet 2 0 9 -1
\bullet 3 0 6 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Softwareprojekt II 
\end_layout

\begin_layout Title
\begin_inset Quotes pld
\end_inset

Untersuchung zu den Begriffen Gültigkeit und Beweisbarkeit in einer mathematisch
en Theorie
\begin_inset Quotes prd
\end_inset


\end_layout

\begin_layout Author
Reto Hablützel, Max Schrimpf
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Einleitung
\end_layout

\begin_layout Subsection
Aufgabenstellung
\end_layout

\begin_layout Quote
Es soll augehend von einem gegebenen einfachen Axiomensystem (z.B “Gruppe”)
 ein einfacher Satz einereits bewiesen werden und anderseits seine “Gültigkeit”
 illustriert werden.
 Ein Beweis soll entlang von gegebenen formalisierten Schlussregeln erfolgen,
 von der Gültigkeit soll man sich mittels “durchrechnen” überzeugen, bei
 unendlichen Strukturen mit einer zufallsgenerierten Auswahl von Fällen.
 
\end_layout

\begin_layout Standard
Ausgehend von dieser vorgegebenen Aufgabenstellung soll in der vorliegenden
 Projektarbeit eine Implementation mit der Fähigkeit die Gültigkeit eines
 Axiomsystemes in den Grundsätzen zu bewisen, erarbeitet werden.
 Durch das enorme Wachstum der Ausgangswerte sind dabei schon relativ kleine
 Systeme mit bedeutendem Rechenaufwand verbunden, weshalb ein sinnvoller
 Ansatz zum Umhang mit rechenintensiven Aufgaben gefunden werden muss.
 
\end_layout

\begin_layout Standard
Die genaue Schwerpunktsetzung bei der Umsetzung und das Vorgehen war dabei
 durch die offene Aufgabenstellung dem Projektteam überlassen.
 Vorgegeben war mur die Implementation eines automatisierten Gültigkeitsbeweises
 des Satzes zur Rechtsauslöschung in Gruppen.
\end_layout

\begin_layout Subsection
Ausgangslage
\end_layout

\begin_layout Standard
Wir konnten uns im letzten Semester als Vertiefungsarbeit im Fach 
\begin_inset Quotes pld
\end_inset

Algorithmen und Datenstrukturen
\begin_inset Quotes prd
\end_inset

 mit dem Thema MapReduce beschäftigen.
 Dazu hatten wir, anhand des Entwrufsmuster (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:MapReduce"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:MapReduce"

\end_inset

), unser eigenes Framework für parallelisierte MapReduce Berechnungen implementi
ert.
 
\end_layout

\begin_layout Standard
Bei der Analyse der vorliegenden Problemstellung kam uns schnell die Idee,
 dass es möglich wäre die im letzten Semester gewonnenen Erkenntnisse sowie
 die bestehende Software zur Umsetzung einer Lösung zu Nutzen.
\end_layout

\begin_layout Standard
Aufgrund der beschränkt zur Verfügung stehenden Zeit, mussten wir es bei
 der damaligen Implementation auf einem einzelnen Rechner mit mehreren Threads
 belassen, anstatt ein ganzes Computernetz verwenden zu können.
 Ausserdem ergaben sich weitere technische Limitierungen.
 So konnte unser Framework zum Beispiel nicht mit dem Szenario eines abnormal
 terminierenden Threads, umgehen.
 Die Handhabung solcher Ereignisse ist, insbesondere im Ausblick auf eine
 echt verteilte Berechnung interessant, da in einem Netzwerk immer wieder
 eine einzelne Maschine aussteigt.
\end_layout

\begin_layout Subsection
Abgeleitete Aufgabenstellung
\end_layout

\begin_layout Standard
Basierend auf unserem Wissen aus den Algebra-Vorlesungen, unserem Interesse
 für verteilte Berechnungen und dem bestehenden MapReduce Framework, einigten
 wir uns mit unserem Betreuenden Dozenten Herrn Heuberger dahingehend, dass
 wir in einem ersten Teil die Prüfung eines Satzes für ein bestimmtes Axiomsyste
m als MapReduce Problem formulieren und dieses dann mit unserem Framework
 ausführen sollten.
 
\end_layout

\begin_layout Standard
Anschliessend daran wurde uns die Option gewährt selbst eine vertiefende
 Weiterführung der Projektarbeit mit den in Teil 1 erworbenen Kenntnissen
 wählen.
 Hierzu mehr im Kapitel 
\begin_inset Quotes pld
\end_inset


\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Möglichkeiten-der-Vertiefung"

\end_inset


\begin_inset Quotes prd
\end_inset

.
\end_layout

\begin_layout Subsection
MapReduce
\begin_inset CommandInset label
LatexCommand label
name "sub:MapReduce"

\end_inset


\end_layout

\begin_layout Standard
MapReduce ist ein Entwurfsmuster, welches die parallele Verarbeitung grosser
 Datenmengen vereinfachen soll und erstmals von Jeffrey Dean und Sanjay
 Ghemawat aus dem Google research Team beschrieben 
\begin_inset CommandInset citation
LatexCommand cite
key "MapReduce"

\end_inset

 sowie in einem Framework implementiert wurde.
 Google ist mit dem Problem grosser Datenmengen zum Beispiel beim erstellen
 der 
\begin_inset Quotes pld
\end_inset

Google Suche
\begin_inset Quotes prd
\end_inset

 konfrontiert.
 Hierbei muss quasi das gesammte Internet indexiert werden und durchsucht
 werden um es für die Suche in geeigneter Form aufzubereiten.
 
\end_layout

\begin_layout Standard
Um ein Programm so zu entwickeln, dass es auf einer verteilten Architektur
 gut skaliert, ist jedoch ein enormer Aufwand, welcher nichts mit dem eigentlich
 zu lösenden Problem zu tun hat, nötig.
 Daher wurde das Framework so konzipiert, dass es Benutzern erlaubt ihr
 Problem in zwei nur Phasen zu definieren ohne sich Gedanken um die anschliessen
de Verteilung und Berechnung machen zu müssen.
 So kümmert sich das Framework zum Beispiel darum, was passiert, wenn eine
 Maschine ausfällt oder wie die einzelnen Arbeittsschritte auf die verschiedenen
 Maschinen aufgeteilt werden.
\end_layout

\begin_layout Standard
Die zwei Phasen des Entwurfsmusters sind, wie der Name berieits suggeriert,
 Map und Reduce (mit einer eine optionalen, zwischenliegenden, für das Verständn
is irrelevanten Combiner Phase).
 In diesen Phasen werden im Wesentlichen die beiden Funktionen Map und Reduce
 aufgerufen, welche hier kurz erklärt werden sollen.
\end_layout

\begin_layout Verse
\begin_inset Formula 
\[
map\footnote{Schreibweise:\, a\, ist\, ein\, Element\, aus\, einer\, Menge\, A}:(a\rightarrow b)\rightarrow A\rightarrow B
\]

\end_inset


\end_layout

\begin_layout Standard
Die Map Funktion bildet eine Menge von Elementen elementweise auf eine neue
 Menge ab.
 Dazu müssen ihr zwei Parameter übergeben werden – eine Funktion, welche
 eine Element aus der Menge 
\begin_inset Formula $A$
\end_inset

 auf ein Element in der Menge 
\begin_inset Formula $B$
\end_inset

 abbildet und eine Menge von Elementen A.
 Daraufhin wird die Funktion sukzessive auf die Elemente der Liste 
\begin_inset Formula $A$
\end_inset

 angewendet und somit die Menge 
\begin_inset Formula $B$
\end_inset

 konstruiert, welche das Resultat ist.
 
\end_layout

\begin_layout Verse
\begin_inset Formula 
\[
reduce:(b\rightarrow c\rightarrow c)\rightarrow c\rightarrow B\rightarrow c
\]

\end_inset


\end_layout

\begin_layout Standard
Die Reduce Funktion bildet eine Menge 
\begin_inset Formula $B$
\end_inset

 auf einen einzelnen Wert ab 
\begin_inset Formula $c$
\end_inset

.
 Dafür erhält sie als ersten Parameter eine Funktion, mit einen Wert aus
 der Menge 
\begin_inset Formula $B$
\end_inset

 sowie einen Akkumulator, welche einen Wert 
\begin_inset Formula $b$
\end_inset

 zurückgibt.
 Als zweiten Parameter erhält die Reduce Funktion einen initialen Wert für
 den Akkumulator und als dritten und letzten Parameter die Menge 
\begin_inset Formula $B$
\end_inset

.
 Dann wird die übergebene Funktion mit jedem Element aus der Menge 
\begin_inset Formula $B$
\end_inset

 und dem Akkumulator aufgerufen.
 Dabei ist das Resulat der Funktion jeweils der neue Wert für den Akkumulator.
 Sobald die ganze Liste traversiert wurde, ist der Wert vom Akkumulator
 das Resultat.
\end_layout

\begin_layout Standard
Der Benutzer des MapReduce Frameworks muss also für eine auszuführende Berechnun
g nur noch eine Funktion schrieben, welche ein Element aus der Menge 
\begin_inset Formula $A$
\end_inset

 auf ein Element in der Menge 
\begin_inset Formula $B$
\end_inset

 abbildet (Map Phase), eine Funktion schreiben, welche für ein Element aus
 der Menge 
\begin_inset Formula $B$
\end_inset

, kombiniert mit einem Akkumulator, auf ein Element aus der Menge 
\begin_inset Formula $C$
\end_inset

 abbildet (Reduce Phase) und initial die Menge
\begin_inset Formula $A$
\end_inset

 bereitstellen.
 
\end_layout

\begin_layout Standard
Für das MapReduce Framework ist es daraufhin möglich zum Beispiel die erste
 Funktion mit einem Element aus der Menge 
\begin_inset Formula $A$
\end_inset

 an eine berechnende Maschine senden.
 Auch ordnet das Framework in mit einem sogenannten Shuffle nach der Map
 Phase die Elemente so an, dass sie von der Reduce Phase verarbeitet werden
 können.
 Die Anordnung der Elemente der Menge 
\begin_inset Formula $B$
\end_inset

 muss dabei zu beginn der Reduce Phase nicht zwingend ihrer Anordnung nach
 der Map Phase entsprechen.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename MapReduce Uebersicht.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Übersicht über die Phasen des MapReduce
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wie die Grafik illustriert, gibt es in der Map Phase keine Datenabhängigkeiten
 der einzelnen Elemente (1:1 Mapping), weshalb jede Funktionsanwendung sehr
 gut auf verschiedenen Maschinen ausgeführt werden kann.
 Die Map Phase gilt als abgeschlossen, wenn sämtliche Elemente aus der Menge
 
\begin_inset Formula $A$
\end_inset

 auf ein Element in der Menge 
\begin_inset Formula $B$
\end_inset

 abgebildet wurden.
 Nun kann das MapReduce Framework auf einer Maschine die Reduce-Phase durchführe
n.
 Hierbei ist wichtig zu bemerken, dass die Reduce Funktion nicht äquivalent
 parallelisiert werden kann, da es Datenabhängigkeiten gibt.
 Eine parallele Verarbeitung ist nur möglich, wenn die Reduce Funktion assoziati
v ist.
 In diesem Fall könnte die Reduce-Phase in einer Art Baum-Struktur ausgeführt
 werden – auf solche für das verständnis nicht förderlichen Details soll
 jedoch im folgenden nicht weiter eingegangen werden.
\end_layout

\begin_layout Standard
Hier ein Beispiel umd die Idee der zwei Phasen des MapReduce zu verdeutlichen.
 Wir definieren ein initiale Menge an Elementen 
\end_layout

\begin_layout Verse
\begin_inset Formula 
\[
A=\left\{ 1,2,3,4\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
eine Funktion für die Map Phase
\end_layout

\begin_layout Verse
\begin_inset Formula 
\[
f_{m}\: x=x^{2}
\]

\end_inset


\end_layout

\begin_layout Standard
und eine Funktion für die Reduce Phase
\end_layout

\begin_layout Verse
\begin_inset Formula 
\[
f_{r}\: x\: a=x+a.
\]

\end_inset


\end_layout

\begin_layout Standard
Nach der Map Phase entsteht die Menge 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
B=\{1,4,9,16\}.
\]

\end_inset

Welche in der der Reduce Phase aufaddiert
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Der initiale Akkumulator ist in diesem Fall das erste Element aus der Menge
 B oder 0.
\end_layout

\end_inset

 wird und als Endresultat die einelementige Menge 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
C=\{30\}
\]

\end_inset

ergibt
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Teil 1 Gültigkeit des Satzes zur Rechtsauslöschung in Gruppen
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Ausgangslage"

\end_inset

Mathematische Grundlagen
\end_layout

\begin_layout Subsubsection
Gruppe
\end_layout

\begin_layout Standard
Eine Gruppe ist eine algebraische Struktur bestehend aus einer Menge S und
 einer Verknüpfung 
\begin_inset Formula $\diamond$
\end_inset

, welche die folgenden Axiome erfüllt:
\end_layout

\begin_layout Itemize
Assoziativität: 
\begin_inset Formula $\forall a,b,c.\:\left(a\diamond b\right)\diamond c\:=a\diamond\left(b\diamond c\right)$
\end_inset


\end_layout

\begin_layout Itemize
Neutrales Element: 
\begin_inset Formula $\exists e.\:\forall a.\:\left(a\diamond e=e\diamond a=a\right)$
\end_inset


\end_layout

\begin_layout Itemize
Inverses Element
\begin_inset Foot
status open

\begin_layout Plain Layout
Hierbei ist e das neutrale Element
\end_layout

\end_inset

: 
\begin_inset Formula $\forall a.\:\exists b.\:\left(a\diamond b=e\right)$
\end_inset


\end_layout

\begin_layout Standard
Es gibt verschiedene Strukturen, die diese Eigenschaften haben.
 Ein Beispiel davon ist die Restklasse 3 mit einer Operation definiert als:
 
\begin_inset Formula $x\diamond y=(x+y)\,\%\,3$
\end_inset

, also die gewöhnliche Addition in dieser Restklasse.
 Für diese Struktur kann man nun beweisen, dass sie eine Gruppe ist, indem
 man sich überzeugt, dass die Addition assoziativ ist, dass ein neutrales
 Element existiert (nämlich 0) und dass jedes Element ein inverses Element
 hat, mit welchem es auf die 0 abbildet (z.B.
 
\begin_inset Formula $1\diamond2=0$
\end_inset

).
 
\end_layout

\begin_layout Standard
Es gibt weit mehr Strukturen, die als Gruppe eingestuft werden können.
 Es ist zum Beispiel durch stupides ausprobieren, also mechanische Arbeit,
 die bestens für einen Computer geeignet ist, da sie strikt regelgesteuert
 abläuft, möglich diese zu finden.
 Genau dies soll der erste Schritt unserer Arbeit sein.
 Natürlich gibt es unendlich viele Möglichkeiten für Gruppen, daher ist
 es klar, dass wir mit unseren Berechnungen nur einen gewissen Bereich abdecken
 können.
 Jedoch ist dieser Bereich enorm klein, da bereits bei wenigen Elementen
 eine enorme Rechenleistung, welche sequenziell de facto unerreichbar wäre,
 erforderlich ist.
 Genau hier kommt unser MapReduce Framework zur paralellen Berechnung ins
 Spiel.
\end_layout

\begin_layout Subsubsection
Satz
\end_layout

\begin_layout Quotation
Ein Satz oder Theorem ist in der Mathematik eine widerspruchsfreie logische
 Aussage, die mittels eines Beweises als wahr erkannt, das heißt, aus Axiomen
 und bereits bekannten Sätzen hergeleitet werden kann.
\begin_inset CommandInset citation
LatexCommand cite
key "Satz_Wiki"

\end_inset


\end_layout

\begin_layout Standard
Nachdem wir mittels des MapReduce Frameworks irgendwelche Strukturen gefunden
 haben, welche, eventuell per Zufall, die Axiome einer Gruppe erfüllen,
 können wir in einem zweiten Schritt noch prüfen, ob für diese auch bestimmte
 Sätze zutreffen.
 Im Gegensatz zu den Gruppen-Axiomen gibt es keine definierte Menge an Sätzen,
 welche für eine Gruppe gültig sind.
 Es werden ständig neue Sätze gefunden und ausserdem existieren Sätze, für
 die noch nicht allgemeingültig bewiesen werden konnte, dass sie für sämtliche
 Gruppen gelten, für die aber ebenso noch kein Gegenbespiel oder Gegebeweis
 gefunden werden konnte.
 Trotzdem wir mit den vorhandenen Mitteln keine allgemeingültigen Beweise
 führen können, ist es mit genügend Rechenleistung ein Ansatz nach Gegenbespiele
n, also bestimmte Konstellationen von Mengen und Verknüpfungen, welche zwar
 eine Gruppe sind, aber einen bestimmten Satz nicht erfüllen, zu suchen.
 Ein Beispiel eines Satzes, ist der Satz der Rechtsauslöschung:
\end_layout

\begin_layout Verse
\begin_inset Formula 
\[
\forall a,b,c.\: b\diamond a=c\diamond a\Rightarrow lb=c
\]

\end_inset


\end_layout

\begin_layout Standard
Sämtliche Strukturen, welche die Axiome der Gruppe erfüllen, erfüllen auch
 diesen Satz.
 Den Beweis dazu findet man online
\begin_inset CommandInset citation
LatexCommand cite
key "CancellationLawsProofWiki"

\end_inset

.
\end_layout

\begin_layout Subsection
Generieren von Gruppen mittels Computer
\begin_inset CommandInset label
LatexCommand label
name "sub:Generieren-von-Gruppen"

\end_inset


\end_layout

\begin_layout Standard
Es gibt unendlich viele Mengen und darauf mögliche Verknüpfungen.
 In unserer Implementation kann bei Programmstart angegeben werden nach
 Mengen mit wie vielen Elementen gesucht werden soll
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Aus technischen Gründen war es jedoch nötig die mögliche Anzahl an Elementen
 auf 9 zu beschränken.
\end_layout

\end_inset

.
 Um Gruppen zu finden, haben wir einen Algorithmus implementiert, welcher
 alle möglichen zweistelligen Verknüpfungen auf einer endlichen Menge generiert.
 Grafisch können diese Verknüpfungen als Wertetabellen interpreiert werden.
 So wie bei diesen Beispielen für mögliche Verknüpfungen mit zwei Elementen:
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Intuitive Addition der Restklasse 2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Weitere mögliche Wertetabellen einer Verknüpfung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Insgesamt gibt es 16 mögliche Permutationen für Wertetabellen von zweistellige
 Verknüpfungen bei einer Menge aus 2 Elementen.
 Für eine Menge aus 3 Elementen sind es Bereits 19 683.
 Allgemein fomuliert besitzt eine Menge mit 
\begin_inset Formula $n$
\end_inset

-Elementen 
\begin_inset Formula $n^{n*n}$
\end_inset

 mögliche Wertetabellen für zweistellige Verknüpfungen.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mögliche Wertetabellen für zweistellige Verknüpfungen
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19 683
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 294 967 296
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
298 023 223 876 953 125
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10 314 424 798 490 535 546 171 949 056
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256 923 577 521 058 878 088 611 477 224 235 621 321 607
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Mögliche Permutationen einer zweistelligen Verknüpfung in einem n-Elementigen
 System 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Weiterhin gibt es in jeder Gruppe ein für jedes Element ein inverses Element
 bezüglich der zweistelligen Verknüpfung.
 Um alle möglichen inversen Elemente zu finden, haben wir für diese einstellige
 Verknüpfung ebenfalls Wertetabellen generiert.
 Folgend zwei Beispiele für Wertetabellen mit zwei Elementen:
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a^{-1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a^{-1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Beispiele für einstellige Verknüpfungen mit zwei Elementen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Für eine Gruppe aus zwei Elementen gibt es also 4 mögliche Wertetabellen
 und allgemein gibt es 
\begin_inset Formula $2^{n}$
\end_inset

 Möglichkeiten für einstellige Verknüpgungen aus Gruppen mit 
\begin_inset Formula $n$
\end_inset

-Elementen.
 Auch diese Tabellen können wir mit unserem Algorithmus simulieren.
 
\end_layout

\begin_layout Standard
Das neutrale Element ist anschliessend einfach zu finden, da es schlicht
 das Ergebnis der zweistelligen Verknüpfung eines Elementes mit seinem Inversen
 ist.
\end_layout

\begin_layout Standard
Schlussendlich suchen wir Gruppen indem wir eine zweistellige Verknüpfung,
 eine einstellige Verknüpfung und ein neutrales Element, wie im Kapitel
 
\begin_inset Quotes pld
\end_inset


\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Prüfen-der-Axiome"

\end_inset


\begin_inset Quotes prd
\end_inset

, zusammen auf die Axiome überprüfen.
\end_layout

\begin_layout Subsubsection
Datenstruktur der Wertetabellen
\end_layout

\begin_layout Standard
Bereits für Mengen mit drei Elementen gibt es, wie oben gezeitgt, bei der
 zweistelligen Verknüpfung tausende von Möglichkeiten.
 Da wir die Prüfung der Axiome, spätestens für die Berechnung von Gruppen
 aus einer vier-Elementigen Menge, verteilen müssen, gilt es einerseits
 einen Algorithmus finden, der sich auf verschiedene Rechner aufteilen lässt,
 sodass jeder Rechner eine Teilmenge der Wertetabellen überprüfen kann,
 und andererseits diese Teilmengen so abzubilden, dass sie nicht zu viel
 Speicher verbrauchen.
 Auf einem Rechner alle Wertetabellen zu generieren und diese dann an die
 verschiedenen Rechner über das Netz zu schicken ist also nicht praktikabel.
\end_layout

\begin_layout Standard
Nehmen wir als Beispiel die Menge mit zwei Elementen.
 Bei genauerer Betrachtung einer Wertetablle sieht man, dass diese anstatt
 zweidimensional auch eindimensional interpretiert werden könnte
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
d
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Logischer Aufbau einer zweistelligen Verknüpfung für zwei Elemente
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
eindimensional könnte man die abgebildete Wertetabelle folgendermassen interpret
ieren: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\diamond=\left\{ a,b,c,d\right\} 
\]

\end_inset

Diese Interpretation wurde in unserem Projekt zur Abbildung der Wertetabellen
 gewählt.
 
\end_layout

\begin_layout Standard
In der zweidimensionalen Wertetabelle können wir die Funktionswerte mithilfe
 ihrer x und y Indizes ablesen.
 Diese x und y Werte können mit der folgenden Funktion auf den Index in
 der Binärrepräsentation abgebildet werden: 
\begin_inset Formula 
\[
f_{trans2}\left(x,y\right)=y*2+x
\]

\end_inset

Wäre man als Beispiel in der sechsten Wertetabelle an der Abbildung 
\begin_inset Formula $1\diamond0$
\end_inset

 interessiert, würde das 
\begin_inset Formula $x=1,\: y=0$
\end_inset

 entsprechen.
 Transformiert auf die eindimensionale Repräsentation ergibt dies die Binärreprä
sentation 0110 und für den Index 
\begin_inset Formula $f_{trans2}\left(1,0\right)=1$
\end_inset

.
 Also das zweite Element der Binärrepräsentation, was eine eins ist - wir
 in der Wertetabelle.
\end_layout

\begin_layout Standard
Für eine Menge mit zwei Elementen kann man sich leicht überzeugen, dass
 sämtliche Kombinationen die Binärwerte der Zahlen zwischen 0 und 15 sind:
 z.B.
 
\begin_inset Formula $0=\left\{ 0,0,0,0\right\} $
\end_inset

(alles bildet auf 0 ab) oder 
\begin_inset Formula $6=\left\{ 0,1,1,0\right\} $
\end_inset

 (die intuitive Addition der Restklasse 2).
\end_layout

\begin_layout Subsubsection
Generieren der Wertetabellen
\begin_inset CommandInset label
LatexCommand label
name "sub:Generieren-der-Wertetabellen"

\end_inset


\end_layout

\begin_layout Standard
Für eine Menge mit zwei Elementen kann man sich leicht überzeugen, dass
 sämtliche Kombinationen die Binärwerte der Zahlen zwischen 0 und 15 sind:
 z.B.
 
\begin_inset Formula $0=\left\{ 0,0,0,0\right\} $
\end_inset

(alles bildet auf 0 ab) oder 
\begin_inset Formula $6=\left\{ 0,1,1,0\right\} $
\end_inset

 (die intuitive Addition der Restklasse 2).
 Diese Anschauungsweise birgt den Vorteil, dass alle möglichen Wertetabellen
 durch die simple Addition von 1 im Binärsystem generiert werden können.
\end_layout

\begin_layout Standard
Diese Betrachtung kann auch auf das Ternärsystem usw.
 übertragen werden, indem man alle Zahlen von 0 bis 
\begin_inset Formula $3^{3*3}-1$
\end_inset

mit der oben beschriebenen Funktion 
\begin_inset Formula $f_{trans2}$
\end_inset

interpretiert.
 Allgemein können also alle Wertetabellen zweistelliger Verknüpfungen somit
 durch einfache Addition der 1 als zahl in ihrem jeweils korrospondierenden
 Stellenwertsystem interpretiert werden.
\end_layout

\begin_layout Subsubsection
Implementation von Quantoren in Java
\end_layout

\begin_layout Standard
Wie im Kapitel 
\begin_inset Quotes pld
\end_inset


\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Ausgangslage"

\end_inset


\begin_inset Quotes prd
\end_inset

 beschrieben, werden Axiome einer Gruppe und Sätze einer beliebigen Struktur
 mittels Quantoren definiert.
 Als Beispiel soll das Axiom 'Es gibt ein neutrales Element' der Struktur
 Gruppe näher erläutert werden: 
\begin_inset Formula $\exists e\:\forall a\:\left(a\diamond e=e\diamond a=a\right)$
\end_inset

.
 Dieses Axiom verwendet zwei Quantoren: Einen Existenzquantor (
\begin_inset Formula $\exists$
\end_inset

) und einen Allquantor (
\begin_inset Formula $\forall$
\end_inset

).
 Mit dem Existenzquantor wird ausgesagt, dass es in einer bestimmten Struktur
 ein e gibt, für das das folgende Prädikat wahr ist, während mit dem Allquantor
 gesagt wird, dass das Prädikat für alle Elemente dieser Struktur gelten
 muss.
 
\end_layout

\begin_layout Standard
In unserem Beispiel 'Es gibt ein neutrales Element' tauchen diese beiden
 Quantoren direkt nacheinander auf, wodurch dieses Axiom in Prosa folgendermasse
n formuliert werden kann: 
\end_layout

\begin_layout Quotation
In einer Gruppe gibt es ein Element e, welches, wenn es mit irgendeinem
 Element a aus dieser Struktur verknüpft wird, immer auf das Element a abbildet.
 Dabei ist es gleichgültig, ob a mit e verknüpft wird oder e mit a - es
 muss immer auf a abbilden.
 Genau dann, wenn es ein solches Element e gibt, dann ist e das neutrale
 Element dieser Struktur und das Axiom ist erfüllt.
\end_layout

\begin_layout Standard
Da es in Java keine Quantoren gibt, mussten wir Schleifen nutzen, um die
 Axiome zu implementieren.
 Mittels der folgenden Methode wird für ein bestimmtes Element e geprüft,
 ob es das neutrale Element zweistellligen Verknüpfung für eine Gruppe mit
 
\begin_inset Formula $n$
\end_inset

-Elementen ist.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Java,numbers=left"
inline false
status open

\begin_layout Plain Layout

boolean isNeutral(int numEle, int aPerm, int e) {
\end_layout

\begin_layout Plain Layout

  for (int a = 0; a < numEle; a++) {
\end_layout

\begin_layout Plain Layout

    int b = map2d(a, e, aPerm, numEle);
\end_layout

\begin_layout Plain Layout

    if (a != b) { return false; }
\end_layout

\begin_layout Plain Layout

    int c = map2d(e, a, aPerm, numEle);
\end_layout

\begin_layout Plain Layout

    if (a != c) { return false; }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return true;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Beispielimplementation von Quantoren
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Diese Methode besitzt drei Parameter: 
\end_layout

\begin_layout Enumerate
Ein Wert vom Typ Integer, also Ganzzahl, welcher die Anzahl an Elementen
 der zu prüfenden Gruppe repräsentiert.
 
\end_layout

\begin_layout Enumerate
Der Identifikator für die zweistellige Wertetabelle, welcher auch als Ganzzahl
 modelliert ist.
 
\end_layout

\begin_layout Enumerate
Das vermeindlich neutrale Element, für welches diese Funktion prüft, ob
 es wirklich das neutrale Element ist.
 
\end_layout

\begin_layout Standard
In der zweiten Zeile wird durch alle Elemente der Menge iteriert, wodurch
 die Variable a den Wert jedes Elementes einmal annimmt (beginnend bei 0).
 
\end_layout

\begin_layout Standard
In der dritten Zeile wird die Methode map2d aufgerufen, welche das Element
 
\begin_inset Formula $a$
\end_inset

 (also jedes Element der Menge einmal) mit dem neutralen Element 
\begin_inset Formula $e$
\end_inset

 verknüpft.
 Die Methode 
\emph on
map2d 
\emph default
implementiert den von uns entwickelten Algorithmus zur Generierung der Verknüpfu
ngstabellen (vgl.
 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Generieren-der-Wertetabellen"

\end_inset

).
 Der Rückgabewert dieser Funktion wird der Variable 
\begin_inset Formula $b$
\end_inset

 zugewiesen um in der nächsten Zeile mit der Variable 
\begin_inset Formula $a$
\end_inset

 verglichen zu werden.
 Wenn diese Bedingung zutrifft, bedeutet das, dass 
\begin_inset Formula $a\diamond e=e$
\end_inset

 gilt, also ist das 
\begin_inset Formula $e$
\end_inset

 bereits linksneutral.
 Falls 
\begin_inset Formula $e$
\end_inset

 es nicht linksneutral ist, wird die Funktion sofort abgebrochen, da das
 Prädikat einen Allquantor beinhaltet und es somit für alle Elemente gelten
 muss.
 
\end_layout

\begin_layout Standard
Auf den folgenden Zeilen fünf und sechs wird die Variable 
\begin_inset Formula $a$
\end_inset

 nochmals mit dem vermeindlich neutralen Element verknüft um die Rechtsneutralit
ät zu überprüfen (daher sind hier die Parameter 
\emph on

\begin_inset Formula $a$
\end_inset


\emph default
 und
\begin_inset Formula $e$
\end_inset

 für die Funktion map2d vertauscht).
 
\end_layout

\begin_layout Standard
Wenn sämtliche Elemente dieser Gruppe links- und rechtsneutral sind, wird
 die Schleife verlassen und die Funktion erreicht die Zeile Nr.8, in der
 der boolsche Wert 'wahr' zurückgegeben wird.
 Dies bedeutet, dass das Element 
\begin_inset Formula $e$
\end_inset

 tatsächlich das neutrale Element in dieser Struktur ist.
\end_layout

\begin_layout Subsection
Map und Reduce Funktionen für die Aufgabenstellung
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename MapReduce fuer Axiome.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Überprüfen des Satzes als Map und Reduce Funktionen
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Prüfen der Axiome als Map-Funktion
\begin_inset CommandInset label
LatexCommand label
name "sub:Prüfen-der-Axiome"

\end_inset


\end_layout

\begin_layout Standard
Das CPU-intensive überprüfen der Strukturen, welche möglicherweise die Axiome
 erfüllen, wurde als MAP-Funktion definiert.
 Dabei werden den einzelnen rechnenden Einheiten, im folgenden Worker genannt,
 jeweils eine Anzahl an Permutationen der Additionstabelle und ein 
\begin_inset Formula $n$
\end_inset

 im Sinne der derzeit vorhandenen Anzahl an verschiedenen Elementen als
 Input übergeben.
 Die Worker führen dann die Überprüfung der Axiome durch, indem sie jeweils
 für alle Additionstabellen in ihrem Bereich alle möglichen Inversentabellen
 mit allen möglichen neutralen Elementen prüfen.
\end_layout

\begin_layout Standard
Hierbei gibt es Vereinfachungen, die inhaltlich korrekt sind jedoch die
 benötigte Rechenleistungen massiv reduzieren:
\end_layout

\begin_layout Itemize
Sowohl die Additions- wie auch die Permutationstabelle werden nicht immer
 vollständig vor der Prüfung der Axiome aufgestellt, sondern nur bei Bedarf
 bei Bedarf durch die oben beschriebene Algorithmus (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Generieren-der-Wertetabellen"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Generieren-der-Wertetabellen"

\end_inset

) generiert.
 Das heisst der Rechenaufwand wird substantiell reduziert da bei einer Prüfung
 der Axiome im Normalfall nur ein quasi vernachlässigbarer Teil der Additionstab
elle und, abhängig von Erfolg oder Misserfolg der Überprüfungen, auch nur
 ein minimer Teil der Inversentabelle benötigt wird.
\end_layout

\begin_layout Itemize
Für eine gegebene Additions- und Inversen-Tabellenkombination wird jeweils
 nur das neutrale Element, das für den ersten Eintrag in der Inversentabelle
 berechnet wurde, geprüft.
 Da per Definition nur ein neutrales Element für eine spezifische Kombination
 aus Tabellen existiert, muss es auch für alle weiteren Einträge an Inversentabe
llen gelten.
 Sobald ein Eintrag gefunden wurde für den ein anderes neutrales Element
 gelten würde, wird die Berechnung für die vorliegenden Tabellen verworfen
 Auch diese Annahme reduziert substantiell die durchgeführten, nicht zielführend
en Rechnungen.
\end_layout

\begin_layout Standard
Die Ausgabe der Map-Funktion sind schlussendlich alle Gruppen auf die die
 gegebenen Axiome zutreffen.
 Eine Gruppe wird ausreichend durch 3 Zahlen beschrieben:
\end_layout

\begin_layout Itemize
Die eindimensionale Repräsentation der Additionstabelle als String.
 
\end_layout

\begin_layout Itemize
Die indimensionale Repräsentation der Inversentabelle als String.
\end_layout

\begin_layout Itemize
Das neutrale Element der Gruppe.
\end_layout

\begin_layout Standard
Diese effiziente Speicherung ermöglicht das Vorhalten von enorm vielen Gruppen
 ohne einen hohen Speicherbedarf.
\end_layout

\begin_layout Subsubsection
Prüfen der Sätze als Reduce-Funktion
\end_layout

\begin_layout Standard
In der Reduce-Phase wird für die, relativ zur Menge der möglichen Gruppen,
 enorm kleine Menge an effektiven Gruppen der Satz jeweils geprüft.
 Als Output gibt sie die Gruppen für die der Satz nicht zutrifft.
 Da anzunehmen ist, dass somit der Output immer leer ist, kann er auch als
 booleanscher Wahrheitswert interpretiert werden:
\end_layout

\begin_layout Itemize
Wenn der Output leer ist, ist der Satz für die geprüften Gruppen wahr.
\end_layout

\begin_layout Itemize
Wenn der Output nicht leer ist, ist der Satz für die geprüften Gruppen falsch
 (was einer mathematischen Sensation gleich käme).
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Weiteres Vorgehen
\end_layout

\begin_layout Subsection
Möglichkeiten der Vertiefung der Aufgabenstellung
\begin_inset CommandInset label
LatexCommand label
name "sub:Möglichkeiten-der-Vertiefung"

\end_inset


\end_layout

\begin_layout Standard
Wie bereits geschildert, wurde uns die genaue Vertiefung der Aufgabenstellung
 selbst überlassen.
 Für uns kamen drei mögliche Schwerpunkte in Frage auf die zuerst einmal
 näher erläutert werden sollen.
\end_layout

\begin_layout Subsubsection
\noindent
Erweiterung des MapReduce Frameworks
\end_layout

\begin_layout Standard
\noindent
Bei diesem Schwerpunkt wäre die Zielsetzung eine möglichst grosse Kapazität
 Gültigkeiten zu beweisen mit dem MapReduce Framework erweitert um die Möglichke
it von auf mehreren Rechnern verteilten Berechnungen zu erzielen.
 Die enormen Datenmengen, die bereits bei kleinen Eingabewerten entstehen
 sind auf einem einzelnen Rechner spätestens ab Gruppen mit 4 Elementen
 quasi nicht zu bewältigen hierbei ist primär die CPU-Rechenzeit relevant.
 Es müssten daher Möglichkeiten gefunden werden, um eine Menge an Inputwerten
 zu anderen Computern zu senden, dort berechnen zu lassen und für das weitere
 Vorgehen relevante Daten zu returnieren.
\end_layout

\begin_layout Standard

\emph on
Anforderungen bei diesem Schwerpunkt wären primär die Handhabung von verteilten
 Systemen, Design der Applikation und einer performanten Umsetzung.
\end_layout

\begin_layout Subsubsection
Freie Eingabe von auf Gültigkeit zu prüfenden Annahmen
\end_layout

\begin_layout Standard
\paragraph_spacing single
\noindent
Hierbei läge das Hauptaugenmerk darauf einer Eingabesprache um ein Programm
 zum automatisierten Gültigkeitsbeweis zu erstellen.
 Es müsste eine Möglichkeit gefunden werden dem Programm mathematische Strukture
n mit bestimmten Eigenschaften, darauf gültige Axiome und daraus resultierend
 zu prüfende Sätze zu übermitteln.
 Dazu müsste, gleich ob interaktiv oder durch die Auswertung von Eingabedateien,
 eine Eingabesyntax definiert werden und, was wohl die wirkliche Problemstellung
 des Schwerpunktes wäre, eine Auflösung der Syntax und eine darauf basierende
 dynamische Umsezuung in ausführbaren Code.
\end_layout

\begin_layout Standard

\emph on
Anforderungen bei diesem Schwerpunkt lägen primär in der theoretischen Informati
k beim Thema Compilerbau, der dynamischen Generierung einer Interpretation
 der Mathematischen Objekte und schlussendlich ihrem Einbinden sowie Ausführen
 in eine Applikation zur Gültigkeitsprüfung.
\end_layout

\begin_layout Subsubsection
\noindent
Automatisierte Beweisbarkeit
\end_layout

\begin_layout Standard
\noindent
In diesem Fall wäre das Ziel ein Framework zu erstellen welches mit einem
 gegebenen Set aus mathematischen Operationen (zugelassenen Schlussregeln)
 automatisch Sätze aus Eingaben (Sätzen und Axiomen) herleitet.
 Die Operationen, die das System vornehmen könnten entsprächen den im Kalkül
 zugelassenen Schlussregeln.
 Ziel wäre es somit automatisiert mehr oder weniger sinnvolle Aussagen mathemati
sch formell korrekt herzuleiten.
 Dabei müssten Kriterien definiert werden mit denen die Unterscheidung von
 formal korrekten aber irrelevanten und formal korrekten, relevanten Aussagen
 möglich macht.
\end_layout

\begin_layout Standard

\emph on
Anforderungen bei diesem Schwerpunkt wäre wieder die Interpretation der
 in einer gegebenen Syntax vorliegenden Eingaben jedoch des weiteren das
 Erkennen von neuen relevanten Schlussfolgerungen.
 
\end_layout

\begin_layout Subsection
Entscheidung
\end_layout

\begin_layout Standard
Der auf Anhieb spannendste Schwerpunkt stellte nach der ersten Bertrachtung
 die 
\begin_inset Quotes pld
\end_inset

Freie Eingabe von auf Gültigkeit zu prüfenden Annahmen
\begin_inset Quotes prd
\end_inset

 dar.
 Die in dem Schwerpunkt vorkommenden Themen wurden weitestgehend im bisherigen
 Studium noch nicht behandelt und böten somit eine gute Möglichkeit neues
 kennenzulernen.
 
\end_layout

\begin_layout Standard
Die Automatisierte Beweisbarkeit zeigte sich bereits bei der ersten Betrachtung
 als eine eher unwahrscheinliche Vertiefung, da der schlussendliche Nutzen
 massiv in Frage gestellt werdern kann.
 Es wäre zu befürchten, dass eine enorme Menge an Arbeitszeit und Herzblut
 investiert würde um Schlussendlich eine Applikation zu erstellen welche
 Mathematisch völlig irrelevante Sätze herleiten würde.
 
\end_layout

\begin_layout Standard
Eine Erweiterung des MapReduce Framework erschien hingegen bereits nach
 der ersten Analyse als überschaubares Problem im Sinne der Beherrschbarkeit
 der Problemstellung.
 Zwar ist der mit der Vertiefung verbundene Aufand alles andere als als
 klein zu erachten, jedoch sollten keine vollkommen unvorhergesehenen Fragestell
ungen, zu denen ohne eine sehr grosse Menge an Vertiefung keine Lösung gefunden
 werden könnte, auftreten.
\end_layout

\begin_layout Standard
Das Kriterium der Beherrschbarkeit gab schlussendlich auch den Ausschlag
 anstatt der Vertiefung Nr.
 2 eine Erweiterung des Frameworkes anzustreben.
 Die Gefahr durch die enorme Komplexität am Ende nur eine mehr prototypisch
 als sinnvolle Implementation eines Programmes zu erstellen schreckte uns
 ab.
 Desweiteren stellte die Idee mit der gegebenen Infrastruktur der Fachhochschule
 eventuell eine grosse Menge an PCs für einen Feldversuch zu besitzen einen
 grossen Ansporn dar.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Teil 2 MapReduce Framework zur verteilten Berechnung
\end_layout

\begin_layout Subsection
Technologie
\begin_inset CommandInset label
LatexCommand label
name "sub:Technologie"

\end_inset


\end_layout

\begin_layout Standard
In Absprache mit unserem betreuenden Dozenten Herrn Albert Heuberger soll
 an dieser Stelle nur sehr Abstrakt auf die Implementation eingegangen werden.
 Um einen groben Überblick zu gewähren, sind die nun folgende Buzzwords
 leider unumgänglich.
\end_layout

\begin_layout Standard
Als Programmiersprache wählten wir, aufgrund der für den Aufbau eines verteilten
 Rechnernetzes sehr vorteilhaften Betriebssystemunabhängigkeit und unserer
 bereits vorhandenen Kenntnisse, Java aus.
 Git 
\begin_inset CommandInset citation
LatexCommand cite
key "GIT_Home"

\end_inset

 wurde als Versionsverwaltungstool eingesetzt und Bitbucket 
\begin_inset CommandInset citation
LatexCommand cite
key "Bitbucket_Home"

\end_inset

 zum Austausch des Source verwendet.
 Für Build Management wurde Maven 
\begin_inset CommandInset citation
LatexCommand cite
key "MVN_Home"

\end_inset

 eingesetzt, zum Tracking der Testcoverage Cobertura 
\begin_inset CommandInset citation
LatexCommand cite
key "Cobertura_Home"

\end_inset

, für Dependency Injection Guice 
\begin_inset CommandInset citation
LatexCommand cite
key "GUICE_Home"

\end_inset

und für das essentielle Logging die Standardmässige Java Logging API.
\end_layout

\begin_layout Standard
Auf ein GUI wurde mangels Notwendigkeit weitestgehend verzichtet.
 Die Applikation und das Framework lassen sich über Property-Files steuern.
 In einem solchen Property File können einzelne Key-Value Paare angegeben
 werden um bestimmte Aspekte der Berechnung oder Verhalten des Frameworks
 zu definieren.
 Mögliche Konfigurationen sind im Anhang im Kapitel 
\begin_inset Quotes pld
\end_inset


\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Property-Files"

\end_inset


\begin_inset Quotes prd
\end_inset

 einzusehen.
 Auf die genaue Konfigurationsparameter soll an dieser Stelle nicht eingegangen
 werden, da sie aus den Kommentaren ersichtlich sein sollten.
\end_layout

\begin_layout Standard
Als Ausgabe der Applikation werden, neben einem Log, wie beispielhaft im
 Anhang 
\begin_inset Quotes pld
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Beispiel-Output"

\end_inset


\begin_inset Quotes prd
\end_inset

 zu sehen, HTML-Dateien mit den gefundenen Gruppen, im ebenfalls im Anhang
 zu finden, genutzt.
 
\end_layout

\begin_layout Standard
Das Framework besitzt 8800 Lines of Code und die Applikation zum Gültigkeitsbewe
is 1672
\begin_inset Foot
status open

\begin_layout Plain Layout
Code in Java Files, ohne Leerzeilen
\end_layout

\end_inset

.
 Es wurden insgesamt 38 Testklassen mit 149 Verschiedenen Testfällen erstellt
 und somit in den Kernkomponenten zur verteilen Berechnung eine Testcoverage
 von knapp 90% erreicht.
\end_layout

\begin_layout Subsection
Struktur des Frameworks
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename Project Interaction.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Struktur des Frameworks
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Das Framework ist in vier Teile unterteilt:
\end_layout

\begin_layout Enumerate
Ein API das von Projekten, die das Framework einbinden wollen genutzt wird.
\end_layout

\begin_layout Enumerate
Gemeinsame Komponenten von Client und Server
\end_layout

\begin_layout Enumerate
Der MapReduce Client, der Rechenleistung für das Framework zur Verfügung
 stellen kann
\end_layout

\begin_layout Enumerate
Der zentrale MapReduce Server, der die Berechnungen verteilt etc.
\end_layout

\begin_layout Standard
Ein Projekt, das das Framework nutzen will ist hierbei völlig unabhängig
 von Client und Server, da es ausschliesslich die in der API befindlichen
 Interfaces und Klassen einbinden muss.
 Die Konkreten Umsetzungen des API befinden sich davon losgelösst in den
 Client und Server Projekten, von denen eines dem Build Path des Anwendungsproje
ktes hinzugefügt werden muss
\begin_inset Foot
status open

\begin_layout Plain Layout
Leider ist es mit dem derzeitigen Stand noch nicht möglich, dass ein Projekt
 nur auf einem Client ausgeführt wird, welcher die Instruktionen etc an
 den Server sendet.
 
\end_layout

\end_inset

.
 Es ist auch möglich den Client alleinstehend zu starten um einer anderen
 Berechnung Rechenkapazität zur Verfügung zu stellen.
\end_layout

\begin_layout Subsection
Übersicht
\end_layout

\begin_layout Standard
Das Herz unserer MapReduce Implementation ist der Master, er Verwaltet die
 Aufgaben (Tasks) und überwacht ihre Ausführung.
 Ein Task ist eine abstrakte Einheit, welche von einem Worker erfüllt werden
 kann, hier also entweder ein Teil einer Map- oder einer Reduce-Berechnung.
 Im klassischen MapReduce, wie es von Google beschrieben wurde, ist ein
 Worker eine Maschine (PC).
 Somit verteilt eine Hauptmaschine (Master) die verschiedenen Aufgaben an
 verschiedene Rechner in einem Netzwerk.
 
\end_layout

\begin_layout Standard
Davon abweichend ist in unserer Implementation ein Worker nicht zwingend
 eine andere Maschine, sondern schlicht eine abstrakte Einheit, die Arbeit
 ausführen kann.
 In der ersten Version unseres Frameworks gab es, mit lokalen Threads auf
 Maschine des Master, nur eine Art von Workern.
 
\end_layout

\begin_layout Standard
Im Rahmen dieser Projektarbeit wurde die Möglichkeit geschaffen via Plugin
 irgendeine Art von Worker dem Master zu übergeben.
 Somit gibt es also zum Beispiel ein Plugin, welches Threads als Worker
 zur Verfügung stellt und ein Plugin, welches andere Rechner über eine Netzwerk-
Verbindung zur Verfügung stellt.
 Dies wurde soweit abstrahiert, dass in Zukunft auch weitere Arten von Workern
 erstellt werden könnten.
 Denkbar wären dabei zum Beispiel CUDA (NVidia Grafikkarten) oder Android
 Smartphones.
\end_layout

\begin_layout Standard
Die konkrete Verwaltung der Worker wird vom sogenannten Pool übernommen,
 dieser kennt den Status seiner Worker (z.B.
 beschäftigt, frei, unauffindbar, etc) und startet die Berechnung einzelner
 Tasks auf ihnen.
 
\end_layout

\begin_layout Subsection
Ablauf
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Framework overview.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Ablauf einer Berechnung in MapReduce Framework
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Wie im Kapitel 
\begin_inset Quotes pld
\end_inset


\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:MapReduce"

\end_inset


\begin_inset Quotes prd
\end_inset

 beschrieben muss der Benutzer nur eine Map- und eine Reduce Funktion zur
 Nutzung des Frameworks erstellen.
 In unserer Implementation geschieht dies durch von Nutzer erstellte Implementat
ionen der beiden Interfaces 
\emph on
MapInstruction 
\emph default
und 
\emph on
ReduceInstruction.

\emph default
 Diese werden in einer MapReduceTask zusammengefasst und anschliessend mit
 einer Menge an Input dem Framework übergeben 
\family sans
\series bold
\color red
(1)
\family default
\series default
\color inherit
.
 
\end_layout

\begin_layout Standard
Daraus kann dann der Master die Map- und Reduce Instruktionen extrahieren
 und erstellt zunächst aus je einem Teil vom Input und einer Instanz der
 MapInstruction einen MapTask.
 Folglich entstehen für eine MapReduce Berechnung viele MapTasks, welche
 dem Pool zur Verarbeitung übergeben werden 
\family sans
\series bold
\color red
(2)
\family default
\series default
\color inherit
.
 Hier wird vorausgesetzt, dass dem Pool durch ein oder mehrere Plugins bereits
 Worker zur Verfügung gestellt worden sind, da die Tasks sonst niemals ausgeführ
t werden könnten.
 
\end_layout

\begin_layout Standard
Nun kann der Pool einen auszuführenden MapTask einem verfügbaren Worker
 übergeben
\family sans
\series bold
\color red
 (3)
\family default
\series default
\color inherit
.
 Wenn dieser Worker eine andere Maschine im Netz abstrahiert, würde das
 bedeuten, dass dieser MapTask auf einem anderen Rechner ausgeführt wird.
 
\end_layout

\begin_layout Standard
Sobald die Berechnung (z.B.
 auf einem anderen Rechner) ausgeführt wurde, meldet sich der Worker wieder
 beim Pool, sodass bereit ist weitere Aufgaben anzunehmen.
 Also könnte eine ganze Berechnung entweder von einem einzelnen Worker in
 mehreren Schritten oder auf mehrere Worker aufgeteilt ausgeführt werden.
 
\end_layout

\begin_layout Standard
Gleichzeitig prüft der Master kontinuierlich, ob alle MapTasks ausgeführt
 worden sind.
 Sobald alle MapTasks für eine Berechnung ausgeführt worden sind, beginnt
 der Master alle Resultate zu sammeln 
\family sans
\series bold
\color red
(4)
\family default
\series default
\color inherit
 und schliesst somit die Map-Phase ab.
 
\end_layout

\begin_layout Standard
Nach der Map Phase folgt, wie im Kapitel 
\begin_inset Quotes pld
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:MapReduce"

\end_inset


\begin_inset Quotes prd
\end_inset

 beschrieben, die Shuffle-Phase, die die Resultate der Map-Phase nach einem
 Kriterium gruppiert und somit die Reduce-Phase vorbereitet.
 Es ist möglich, dass der User eine von ihm definierte Shuffle Funktion
 angibt um die einfache Gruppierung nach Schlüsseln zu umgehen.
 Da vor der Shuffle-Phase alle MapTasks ausgeführt werden sein müssen, gilt
 dies als Bottleneck von MapReduce.
 Nach der Shuffle-Phase beginnt der Master damit die einzelnen ReduceTasks,
 bestehend aus einer Instanz der ReduceInstruction und einem Teil der Shuffle
 Resultate, zu erstellen und diese wieder dem Pool zu übergeben.
 
\end_layout

\begin_layout Standard
Pool beginnt wiederum diese ReduceTasks den verfügbaren Worker zuzuteilen
 während der Master wieder auf deren Fertigstellung wartet.
 Sobald auch die ReduceTasks berechnet und ihre Ergebnisse abgeholt sind,
 ist die gesammte MapReduce Berechnung abgeschlossen und das Ergebnis wird
 zurückgegeben 
\family sans
\series bold
\color red
(5)
\family default
\series default
\color inherit
.
\end_layout

\begin_layout Subsection
Ablauf bei verteilter Berechnung 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Client Server Interaction.png
	height 7cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Interaktion von Client und Server
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Für das Ausführen von verteilen Berechnungen verwendeten wir das Framework
 SIMON 
\begin_inset CommandInset citation
LatexCommand cite
key "SIMON_Home"

\end_inset

.
 Mit Hilfe dieses Frameworks ist es möglch lokale Methoden Aufrufe auf einer
 entfernten Instanz an einem beliebigen Ort im Netzwerk auszuführen.
 Damit sich der Master nicht um die Komplexitäten im Zusammenhang mit Remote
 Procedure Call (RPC) 
\begin_inset CommandInset citation
LatexCommand cite
key "RPC_Wiki"

\end_inset

 kümmern muss, wird ein einzelner Client, also eine entfernte Instanz, auf
 dem Server genauso wie ein gewöhnlicher Thread als Worker im Pool registriert.
 Die konkrete Implementation dieses Workers ruft aber, anstatt den Task
 direkt auszuführen, via RPC eine Methode auf dem Client auf und übermittelt
 ihm die Instruktion mit zugehörigen Eingabewerten.
\end_layout

\begin_layout Standard
Auf dem Client wartet ein sogenannter SocketAgent ständig darauf, dass er
 Tasks vom Server zugeordnet bekommt.
 Sobald ein Task angekommen ist, wird dieser ausgeführt und die Resultate
 werden wieder an den SocketWorker geschickt, welcher auf dem Server ist.
 Der SocketWorker kümmert sich dann um das korrekte Speichern der Resultate
 und meldet dem Pool, dass er wieder Arbeit aufnehmen kann.
 
\end_layout

\begin_layout Subsection
Speichern von Daten 
\end_layout

\begin_layout Standard
Die Speicherung der Zwischenergebnisse der einzelnen Berechnungen stellt,
 gerade unter dem Aspekt der verteilten Berechnung einen Spannenden Aspekt
 der Implementation dar.
 Die Rahmenbedingungen sind, dass für den Benutzer die Speicherung in den
 einzelnen Instructions immer gleich erscheinen soll, für den Master eine
 schnelle Rückgabe, wenn er die Zwischenergebnisse von einem Task erwartet,
 relevant ist und für Grosse Datenmengen ein Medium gewählt werden muss.
 Diese wiederstrebenden Anforderungen sind wieder mit einer Abstraktion
 gelöst worden: Dem sogenannten Kontext und der Persistenz.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Persistenz von Daten.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Speicherkonzept des Frameworks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zur Speicherung von Zwischenergebnissen werden den einzelnen Instructions
 Kontexte durch die Tasks in denen sie gekapselt sind, übergeben.
 Somit ist es aus Sicht des Tasks und der Instruction nicht transparent
 und nicht relevant, wie gespeichert werden.
 Diese weitere Abstraktion hilft auch enorm bei der Abstraktion des Workers,
 da dieser mit dem Speicherkonzept ansich nicht tangiert wird.
\end_layout

\begin_layout Standard
Die Kontexte sind an die Existenz der einzelnen Tasks gekoppelt und können
 von Ihnen ausgelesen werden daher müssen sie dem Master für seine Abfrage
 der Ergebisse nicht bekannt sein.
 Ausserdem kann eine Task an einem beliebigen Ort, der ihm einen Kontext
 bietet, so auch auf einer anderen Maschine, ausgeführt werden.
 Intern speichern die Kontexte wiederum ihre Daten in eine wie auch immer
 geartete Persistierung der Daten.
\end_layout

\begin_layout Standard
Eine Persistenz kümmert sich um die tatsächliche Speicherung und das Auslesen
 der Daten um auch diese Aufgabe zu abstrahieren.
 Daraus folgt, dass zum Beispiel der Master und ein Client für verteilte
 Berechnungen ihre Daten auf unterschiedliche Arten, je nach beschaffenheit
 des Clients, speichern.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename Pool verhalten.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Interaktion von Task, Pool, Worker und Kontext
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Ergebnisse
\end_layout

\begin_layout Subsection
Anwendung der Applikation
\end_layout

\begin_layout Standard
Wie bereits im Kapitel 
\begin_inset Quotes pld
\end_inset


\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Technologie"

\end_inset


\begin_inset Quotes prd
\end_inset

 erwähnt, wird die Applikation sowie das Framework primär durch Property
 Files gesteuert.
 In einem solchen Property File können einzelne Key-Value Paare angegeben
 wereden um bestimmte Aspekte der Berechnung oder Verhalten des Frameworks
 zu definieren.
 Mögliche Konfigurationen sind im Anhang im Kapitel 
\begin_inset Quotes pld
\end_inset


\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Property-Files"

\end_inset


\begin_inset Quotes prd
\end_inset

 einzusehen.
 Auf die genaue Konfigurationsparameter soll an dieser Stelle nicht eingegangen
 werden, da sie aus den Kommentaren ersichtlich sein sollten.
\end_layout

\begin_layout Subsection
Durchführung 
\end_layout

\begin_layout Subsection
Auswertung der gefundenen Gruppen
\end_layout

\begin_layout Subsection
Schlusswort
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Nutzen der Implementation vs Framework
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Apendix 
\end_layout

\begin_layout Subsection
Property Files
\begin_inset CommandInset label
LatexCommand label
name "sub:Property-Files"

\end_inset


\end_layout

\begin_layout Subsubsection
Applikation
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{hsThesisValidator.properties} 
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Framework
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{mapreduce-defaults.properties} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Beispiel Output
\begin_inset CommandInset label
LatexCommand label
name "sub:Beispiel-Output"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting{log.txt} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename AnzahlElemente1.pdf
	display false
	lyxscale 70
	extra LaTeX "pagecommand=\subsection{Gefundene Gruppen\label{sub:Gefundene-Gruppen}}\subsubsection{Ein Element },frame=true"
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename AnzahlElemente2.pdf
	display false
	lyxscale 70
	extra LaTeX "pagecommand=\subsubsection{Zwei Elemente },frame=true,pages=1"
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename AnzahlElemente2.pdf
	display false
	lyxscale 70
	extra LaTeX "frame=true,pages=2-,pagecommand={}"
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename AnzahlElemente3.pdf
	display false
	lyxscale 70
	extra LaTeX "pagecommand=\subsubsection{Drei Elemente },frame=true,pages=1"
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename AnzahlElemente3.pdf
	display false
	lyxscale 70
	extra LaTeX "frame=true,pages=2-,pagecommand={}"
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename AnzahlElemente4.pdf
	display false
	lyxscale 70
	extra LaTeX "pagecommand=\subsubsection{Vier Elemente },frame=true,pages=1"
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset External
	template PDFPages
	filename AnzahlElemente4.pdf
	display false
	lyxscale 70
	extra LaTeX "frame=true,pages=2-,pagecommand={}"
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "Quellen"
options "alphadin"

\end_inset


\end_layout

\end_body
\end_document
