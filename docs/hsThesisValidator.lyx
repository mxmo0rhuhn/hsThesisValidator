#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language german-ch
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language polish
\papercolumns 1
\papersides 1
\paperpagestyle default
\bullet 0 0 0 -1
\bullet 1 0 8 -1
\bullet 2 0 9 -1
\bullet 3 0 6 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Softwareprojekt II - 
\begin_inset Quotes pld
\end_inset

Untersuchung zu den Begriffen Gültigkeit und Beweisbarkeit in einer mathematisch
en Theorie
\begin_inset Quotes prd
\end_inset


\end_layout

\begin_layout Author
Reto Hablützel, Max Schrimpf
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Einleitung
\end_layout

\begin_layout Subsection
Aufgabenstellung
\end_layout

\begin_layout Quote
Es soll augehend von einem gegebenen einfachen Axiomensystem (z.B “Gruppe”)
 ein einfacher Satz einereits bewiesen werden und anderseits seine “Gültigkeit”
 illustriert werden.
 Ein Beweis soll entlang von gegebenen formalisierten Schlussregeln erfolgen,
 von der Gültigkeit soll man sich mittels “durchrechnen” überzeugen, bei
 unendlichen Strukturen mit einer zufallsgenerierten Auswahl von Fällen..
 
\end_layout

\begin_layout Standard
Ausgehend von dieser vorgegebenen Aufgabenstellung soll in der vorliegenden
 Projektarbeit eine Implementatio,n mit der Fähigkeit die Gültigkeit eines
 Axiomsystemes in den Grundsätzen zu bewisen, erarbeitet werden.
 Durch das enorme Wachstum der Ausgangswerte sind dabei schon relativ kleine
 Systeme mit bedeutendem Rechenaufwand verbunden.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Anzahl Elemente
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Permutationen
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19 683
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 294 967 296
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
298 023 223 876 953 125
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Mögliche Permutationen einer zweistelligen Verknüpfung in einem n-Elementigen
 System 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die genaue Schwerpunktsetzung bei der Umsetzung und das Vorgehen war dabei
 durch die offene Aufgabenstellung dem Projektteam überlassen.
 Vorgegeben war mur die Implementation eines automatisierten Gültigkeitsbeweises
 des Satzes zur Rechtsauslöschung in Gruppen.
\end_layout

\begin_layout Subsection
Ausgangslage
\end_layout

\begin_layout Standard
Wir konnten uns im Rahmen einer Vertiefungsarbeit zum Thema Algorithmen
 und Datenstrukturen bereits mit dem Thema MapReduce beschäftigt.
 Damals hatten wir anhand des wohlbekannten Paradigma (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:MapReduce"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:MapReduce"

\end_inset

) unser eigenes Framework für MapReduce Berechnungen implementiert.
 Aufgrund der beschränkt zur Verfügung stehenden Zeit, mussten wir es damals
 jedoch bei der Ausführung auf einem einzelnen Rechner mit mehreren Threads
 belassen, anstatt ein ganzes Computernetz verwenden zu können.
 Ausserdem gab es weitere technische Limitierungen.
 Zum Beispiel konnte unser Framework nicht mit dem Szenario umgehen, dass
 ein Thread abnormal terminiert.
 Ein solches Konzept wäre insbesondere interessant im Ausblick auf eine
 echt verteilte Berechnung, da in einem Netzwerk immer wieder eine einzelne
 Maschine aussteigt.
\end_layout

\begin_layout Subsubsection
MapReduce
\begin_inset CommandInset label
LatexCommand label
name "sub:MapReduce"

\end_inset


\end_layout

\begin_layout Standard
MapReduce ist ein Entwurfsmuster, welches die parallele Verarbeitung grosser
 Datenmengen vereinfachen soll und erstmals von Google beschrieben und implement
iert wurde.
 Google ist mit dem Problem konfrontiert, dass sie sehr grossen Datenmengen
 verarbeiten müssen.
 Um ein Programm so zu entwickeln, dass es auf einer verteilten Architektur
 gut skaliert, ist jedoch ein enormer Aufwand, welcher nichts mit dem eigentlich
 zu lösenden Problem zu tun hat, nötig.
 Daher entwickelte Google ein Framework, das es dem Benutzer erlaubt sein
 Problem in zwei Phasen zu definieren und die anschliessende Verteilung
 übernimmt.
 Dabei kümmert sich das Framework zum Beispiel darum, was passiert, wenn
 eine Maschine im ausfällt oder wie die einzelnen Arbeittsschritte auf die
 verschiedenen Maschinen aufgeteilt werden.
\end_layout

\begin_layout Standard
Die zwei Phasen sind, wie der Name suggeriert, Map und Reduce (und eine
 optionale, für das Verständnis irrelevante, Combiner Phase).
 In diesen Phasen werden im Wesentlichen die beiden Funktionen Map und Reduce
 aufgerufen, welche hier kurz erklärt werden sollen.
\end_layout

\begin_layout Verse
\begin_inset Foot
status open

\begin_layout Plain Layout
Schreibweise: a ist ein Element aus einer Menge A
\end_layout

\end_inset


\begin_inset Formula $map:(a\rightarrow b)\rightarrow A\rightarrow B$
\end_inset


\end_layout

\begin_layout Standard
Die Map Funktion bildet eine Menge von Elementen elementweise auf eine neue
 Menge ab.
 Dazu muss ihr zwei Parameter übergeben werden – eine Funktion, welche eine
 Element aus der Menge A auf ein Element in der Menge B abbildet und eine
 Menge von Elementen A.
 Daraufhin wird die Funktion sukzessive auf die Elemente der Liste A angewendet
 und somit die Menge B konstruiert, welche das Resultat ist.
 
\end_layout

\begin_layout Verse
\begin_inset Formula $reduce:(b\rightarrow c\rightarrow c)\rightarrow c\rightarrow B\rightarrow c$
\end_inset


\end_layout

\begin_layout Standard
Die Reduce Funktion bildet eine Menge B auf einen einzelnen Wert ab.
 Dafür erhält sie als ersten Parameter eine Funktion, mit einen Wert aus
 der Menge B sowie einen Akkumulator, welcheeinen Wert b zurückgibt.
 Als zweiten Parameter erhält die Reduce Funktion einen initialen Wert für
 den Akkumulator und als dritten und letzten Parameter die Menge B.
 Dann wird die übergebene Funktion mit jedem Element aus der Menge B und
 dem Akkumulator aufgerufen.
 Dabei ist das Resulat der Funktion jeweils der neue Wert für den Akkumulator.
 Sobald die ganze Liste traversiert wurde, ist der Wert vom Akkumulator
 das Resultat.
\end_layout

\begin_layout Standard
Der Benutzer des MapReduce Frameworks muss also für eine auszuführende Berechnun
g nur noch eine Funktion schrieben, welche ein Element aus der Menge A auf
 ein Element in der Menge B abbildet (Map Phase) anschliessend die Menge
 A bereitstellen.
 Auch muss eine Funktion geschrieben werden, welche für ein Element aus
 der Menge B, kombiniert mit einem Akkumulator, auf ein Element aus der
 Menge C abbildet (Reduce Phase).
 Für das MapReduce Framework ist es daraufhin möglich zum Beispiel die erste
 Funktion mit einem Element aus der Menge A an eine berechnende Maschine
 senden.
 Wie die Grafik
\begin_inset Note Note
status open

\begin_layout Plain Layout
muss noch gezeichnet werden..
\end_layout

\end_inset

 zur Map Funktion illustriert, gibt es keine Datenabhängigkeiten (1:1 Mapping),
 weshalb jede Funktionsanwendung sehr gut auf verschiedenen Maschinen ausgeführt
 werden kann.
 Die Map Phase gilt als abgeschlossen, wenn sämtliche Elemente aus der Menge
 A auf ein Element in der Menge B abgebildet wurden.
 Nun kann das MapReduce Framework auf einer Maschine die Reduce-Phase durchführe
n.
 Hierbei ist wichtig zu bemerken, dass die Reduce Funktion nicht äquivalent
 parallelisiert werden dann, da es Datenabhängigkeiten gibt.
 Eine parallele Verarbeitung ist nur möglich, wenn die Reduce Funktion assoziati
v ist.
 Dann könnte die Reduce-Phase in einer Art Baum-Struktur ausgeführt werden
 – darauf soll aber nicht weiter eingegangen werden.
\end_layout

\begin_layout Standard
Folgendendes Beispiel soll die Idee von den zwei Phasen verdeutlichen.
 Dafür definieren wir ein initiale Menge an Elementen A und je eine Funktion
 für die Map Phase 
\begin_inset Formula $f_{m}$
\end_inset

 und eine Funktion für die Reduce Phase 
\begin_inset Formula $f_{r}$
\end_inset

.
\end_layout

\begin_layout Verse
\begin_inset Formula $A=\left\{ 1,2,3,4\right\} $
\end_inset


\end_layout

\begin_layout Verse
\begin_inset Formula $f_{m}\: x=x^{2}$
\end_inset


\end_layout

\begin_layout Verse
\begin_inset Formula $f_{r}\: x\: a=x+a$
\end_inset


\end_layout

\begin_layout Standard
In diesem Beispiel werden in der Map Phase die Elemente aus der Menge A
 quadriert.
 Somit entsteht eine Menge B = {1, 4, 9, 16}.
 In der Reduce Phase werden alle Elemente aus der Menge B aufaddiert
\begin_inset Foot
status open

\begin_layout Plain Layout
Der initiale Akkumulator ist in diesem Fall das erste Element aus der Menge
 B.
\end_layout

\end_inset

.
 Das Endresultat ist also 30.
\end_layout

\begin_layout Subsection
Abgeleitete Aufgabenstellung
\end_layout

\begin_layout Standard
Basierend auf unserem Wissen aus den Algebra - Vorlesungen sowie unserem
 Interesse für verteilte Berechnungen und dem bestehenden MapReduce Framework,
 haben wir uns mit Herrn Heuberger so geeinigt, dass wir in einem ersten
 Teil die Prüfung eines Satzes für ein bestimmtes Axiomsystem als MapReduce
 Problem formulieren und dieses dann mit unserem Framework ausführen.
 Die konkrete Aufgabenstellung für den zweiten Teil haben wir zu beginn
 noch offen gelassen.
 Einen Variantenvergleich ist im Kapitel 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Möglichkeiten-der-Vertiefung"

\end_inset

 
\begin_inset Quotes pld
\end_inset


\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Möglichkeiten-der-Vertiefung"

\end_inset


\begin_inset Quotes prd
\end_inset

 zu finden.
\end_layout

\begin_layout Section
Umsetzung - Teil 1 Gültigkeit des Satzes zur Rechtsauslöschung in Gruppen
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Ausgangslage"

\end_inset

Ausgangslage
\end_layout

\begin_layout Subsubsection
Gruppe
\end_layout

\begin_layout Standard
Eine Gruppe ist eine algebraische Struktur bestehend aus einer Menge S und
 einer Verknüpfung 
\begin_inset Formula $\diamond$
\end_inset

, welche die folgenden Axiome erfüllt:
\end_layout

\begin_layout Itemize
Assoziativität: 
\begin_inset Formula $\forall a,b,c.\:\left(a\diamond b\right)\diamond c\:=a\diamond\left(b\diamond c\right)$
\end_inset


\end_layout

\begin_layout Itemize
Neutrales Element: 
\begin_inset Formula $\exists e.\:\forall a.\:\left(a\diamond e=e\diamond a=a\right)$
\end_inset


\end_layout

\begin_layout Itemize
Inverses Element
\begin_inset Foot
status open

\begin_layout Plain Layout
Hierbei ist e das neutrale Element
\end_layout

\end_inset

: 
\begin_inset Formula $\forall a.\:\exists b.\:\left(a\diamond b=e\right)$
\end_inset


\end_layout

\begin_layout Standard
Es gibt verschiedene Strukturen, die diese Eigenschaften haben.
 Ein Beispiel davon ist die Restklasse 3 mit einer Operation definiert als:
 
\begin_inset Formula $x\diamond y=(x+y)\,\%\,3$
\end_inset

, also die gewöhnliche Addition in dieser Restklasse.
 Für diese Struktur kann man nun beweisen, dass sie eine Gruppe ist, indem
 man sich überzeugt, dass die Addition assoziativ ist, dass ein neutrales
 Element existiert (nämlich 0) und dass jedes Element ein inverses Element
 hat, mit welchem es auf die 0 abbildet (z.B.
 
\begin_inset Formula $1\diamond2=0$
\end_inset

).
 Es gibt weit mehr Strukturen, die als Gruppe eingestuft werden und mit
 ausprobieren findet man einige.
 Diese mechanische Arbeit, also das Suchen solcher Strukturen, könnte uns
 ein Computer abnehmen und genau das ist ein Teil unserer Arbeit.
 Natürlich gibt es unendlich viele Möglichkeiten, weshalb wir diese Aufgabe
 zwar einschränken werden müssen, aber um trotzdem eine möglichst hohe Rechenpow
er zur Verfügung zu haben, haben wir uns entschieden, die Suche mit unserem
 MapReduce Framework auszuführen.
\end_layout

\begin_layout Subsubsection
Satz
\end_layout

\begin_layout Quotation
Ein Satz oder Theorem ist in der Mathematik eine widerspruchsfreie logische
 Aussage, die mittels eines Beweises als wahr erkannt, das heißt, aus Axiomen
 und bereits bekannten Sätzen hergeleitet werden kann.
\begin_inset Foot
status open

\begin_layout Plain Layout
Aus Wikipedia, der freien Enzyklopädie: http://de.wikipedia.org/wiki/Satz_(Mathema
tik)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nachdem wir mittels dem MapReduce Framework irgendwelche Strukturen gefunden
 habe, welche (evt.
 per Zufall) die Axiome einer Gruppe erfüllen, können wir in einem zweiten
 Schritt noch prüfen, ob für diese auch bestimmte Sätze zutreffen.
 Im Gegensatz zu den Gruppen-Axiomen gibt es keine definierte Menge an Sätzen,
 welche für eine Gruppe gültig sind.
 Es werden ständig neue Sätze gefunden und ausserdem existieren Sätze, für
 die noch nicht allgemeingültig bewiesen werden konnte, dass sie für sämtliche
 Gruppen gelten - es wurde aber auch noch kein Gegenbespiel gefunden.
 Während wir mit dem MapReduce Framework zwar keine allgemeingültigen Beweise
 führen können, können wir aber mit sehr viel Rechenpower nach Gegenbespielen
 suchen, also bestimmte Konstellationen von Mengen und Verknüpfungen auf
 diesen, welche zwar eine Gruppe sind, aber einen bestimmten Satz nicht
 erfüllen.
 Ein Beispiel eines Satzes, ist der Satz der Rechtsauslöschung:
\end_layout

\begin_layout Verse
\begin_inset Formula $\forall a,b,c.\: b\diamond a=c\diamond a\Rightarrow b=c$
\end_inset


\end_layout

\begin_layout Standard
Sämtliche Strukturen, welche die Axiome der Gruppe erfüllen, erfüllen auch
 diesen Satz.
 Den Beweis dazu findet man online
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.proofwiki.org/wiki/Cancellation_Laws
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Generieren von Gruppen mittels Computer
\begin_inset CommandInset label
LatexCommand label
name "sub:Generieren-von-Gruppen"

\end_inset


\end_layout

\begin_layout Standard
Da es unendlich viele mögliche Mengen und Verknüpfungen gibt, haben wir
 uns auf die Restklassen als Mengen beschränkt.
 Eine bestimmte Restklasse kann beim Programmstart angegeben werden.
 Um mögliche Verknüpfungen auf einer Restklasse zu finden, haben wir einen
 Algorithmus implementiert, welcher alle möglichen zweistelligen Verknüpfungen
 auf einer endlichen Menge generiert.
 Grafisch können diese Verknüpfungen als Wertetabellen interpreiert werden.
 Folgend sind drei Beispiele für mögliche Verknüpfungen auf der Restklasse
 2.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Die mittlere Tabelle ist die intuitive Addition auf dieser Restklasse und
 die beiden anderen sind mit zufälligen Werten gefüllt.
 Insgesamt gibt es für die Restklasse 2 also 16 mögliche Wertetabellen,
 welche mit dem Computer generiert werden können.
 Aus diesem Beispiel wird ersichtlich, dass es für die Restklasse 2 16 mögliche
 Verknüpfungstabellen gibt, welche wir mit dem Computer simuliert haben.
 Für die Restklasse 3 sind es schon deren 19683.
 Eine Restklasse n hat allgemein fomuliert 
\begin_inset Formula $n^{n*n}$
\end_inset

 mögliche Verknüpfungen.
\end_layout

\begin_layout Standard
Ausserdem gibt es in jeder Gruppe ein inverses Element.
 Um alle möglichen inversen Elemente zu finden, haben wir auch für diese
 einstellige Verknüpfung Wertetabellen generiert.
 Folgend zwei Beispiele für Verknüpfungen auf der Restklasse 2.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a^{-1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset space \qquad{}
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a^{-1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Für die Restklasse 2 gibt es also 4 mögliche Wertetabellen und für eine
 Restklasse n gibt es 
\begin_inset Formula $2^{n}$
\end_inset

 Möglichkeiten.
 Auch diese Tabellen können wir mit unserem Algorithmus simulieren.
\end_layout

\begin_layout Standard
Das neutrale Element ist einfach zu finden, weil jedes Element als neutrales
 gelten kann.
\end_layout

\begin_layout Standard
Schlussendlich suchen wir Gruppen indem wir eine zweistellige Verknüpfung,
 eine einstellige Verknüpfung und ein neutrales Element zusammen auf die
 Axiome überprüfen.
 Dazu prüfen wir jede Kombination dieser drei Komponenten in der Map Phase.
 Die genaue Formulierung dieses Problems als Map Funktion ist im nächsten
 Abschnitt beschrieben.
\end_layout

\begin_layout Subsubsection
Implementationsdetails zur Generierung sämtlicher Wertetabellen
\end_layout

\begin_layout Standard
Bereits für die Restklasse 3 gibt es bei der zweistelligen Verknüpfung tausende
 von Möglichkeiten.
 Die Restklasse 4 passt wahrscheinlich schon nicht mehr in den Hauptspeicher
 eines Computers.
 Da wir diese Berechnung verteilen müssen wir also einerseits einen Algorithmus
 finden, der sich auf verschiedene Rechner aufteilen lässt, sodass jeder
 Rechner eine Teilmenge der Wertetabellen überprüfen kann, und diese Teilmenge
 sollte nicht zu viel Speicher verbrauchen.
 Auf dem Master alle Wertetabellen zu generieren und diese dann an die verschied
enen Worker (Rechner) über das Netz zu schicken ist also nicht praktikabel.
\end_layout

\begin_layout Standard
Nehmen wir als Beispiel die Restklasse 2.
 Bei genauerer Betrachtung einer Wertetablle sieht man, dass diese anstatt
 zweidimensional auch eindimensional interpretiert werden können.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
d
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Eindimensional sähe die abgebildete Wertetabelle folgendermassen aus: 
\begin_inset Formula $\diamond=\left\{ a,b,c,d\right\} $
\end_inset

.
 Vor allem in der Restklasse 2 kann man sich leicht überzeugen, dass sämtliche
 Kombinationen die Binärwerte der Zahlen zwischen 0 und 15 sind: z.B.
 
\begin_inset Formula $0=\left\{ 0,0,0,0\right\} $
\end_inset

(alles bildet auf 0 ab) oder 
\begin_inset Formula $6=\left\{ 0,1,1,0\right\} $
\end_inset

 (die intuitive Addition der Restklasse 2).
 In der zweidimensionalen Wertetabelle konnten wir die Funktionswerte mithilfe
 der x und y Indizes ablesen.
 Diese x und y Werte können mit der folgenden Funktion auf den Index in
 der Binärrepräsentation abgebildet werden: 
\begin_inset Formula $f_{trans2}\left(x,y\right)=y*2+x$
\end_inset


\end_layout

\begin_layout Standard
Wäre man als Beispiel in der sechsten Wertetabelle an der Abbildung 
\begin_inset Formula $1\diamond0$
\end_inset

 interessiert, würde das 
\begin_inset Formula $x=1,\: y=0$
\end_inset

 entsprechen.
 Transformiert auf die eindimensionale Repräsentation ergibt dies die Binärreprä
sentation 0110 und für den Index 
\begin_inset Formula $f_{trans2}\left(1,0\right)=1$
\end_inset

.
 Also das zweite Element der Binärrepräsentation, was eine eins ist - wir
 in der Wertetabelle.
\end_layout

\begin_layout Subsubsection
Implementierung von Quantoren in Java
\end_layout

\begin_layout Standard
Wie im Kapitel 
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Ausgangslage"

\end_inset

 beschrieben, werden Axiome einer Gruppe und Sätze einer beliebigen Struktur
 mittels Quantoren definiert.
 Als Beispiel soll das Axiom 'Es gibt ein neutrales Element' der Struktur
 Gruppe näher erläutert werden: 
\begin_inset Formula $\exists e.\:\forall a.\:\left(a\diamond e=e\diamond a=a\right)$
\end_inset

.
 Dieses Axiom verwendet zwei Quantoren: Einen Existenzquantor (
\begin_inset Formula $\exists$
\end_inset

) und einen Allquantor (
\begin_inset Formula $\forall$
\end_inset

).
 Mit dem Existenzquantor wird ausgesagt, dass es in einer bestimmten Struktur
 ein e gibt, für das das folgende Prädikat wahr ist, während mit dem Allquantor
 gesagt wird, dass das Prädikat für alle Elemente dieser Struktur gelten
 muss.
 In unserem Beispiel 'Es gibt ein neutrales Element' tauchen diese beiden
 Quantoren direkt nacheinander auf, wodurch dieses Axiom in Prosa folgendermasse
n formuliert werden kann: In einer Gruppe gibt es ein Element e, welches,
 wenn es mit irgendeinem Element a aus dieser Struktur verknüpft wird, immer
 auf das Element a abbildet.
 Dabei ist es gleichgültig, ob a mit e verknüpft wird oder e mit a - es
 muss immer auf a abbilden.
 Genau dann, wenn es ein solches Element e gibt, dann ist e das neutrale
 Element dieser Struktur und das Axiom ist erfüllt.
\end_layout

\begin_layout Standard
Da es in Java keine Quantoren gibt, haben wir uns Schleifen zu hilfe genommen
 um die Axiome zu implementieren.
 Mittels der folgenden Funktion wird für ein bestimmtes Element e geprüft,
 ob es das neutrale Element einer bestimmten Restklasse
\begin_inset Foot
status open

\begin_layout Plain Layout
Wir haben als Beispiel die Restklassen verwendet, aber dies würde genauso
 mit anderen Gruppen funktionieren.
\end_layout

\end_inset

 für eine bestimmte Wertetabelle ist.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=Java,numbers=left"
inline false
status open

\begin_layout Plain Layout

boolean isNeutral(int modulo, int aPerm, int e) {
\end_layout

\begin_layout Plain Layout

  for (int a = 0; a < modulo; a++) {
\end_layout

\begin_layout Plain Layout

    int b = map2d(a, e, aPerm, modulo);
\end_layout

\begin_layout Plain Layout

    if (a != b) { return false; }
\end_layout

\begin_layout Plain Layout

    int c = map2d(e, a, aPerm, modulo);
\end_layout

\begin_layout Plain Layout

    if (a != c) { return false; }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return true;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Diese Funktion nimmt drei Parameter: Der erste ist ein Wert vom Typ Integer,
 also eine Ganzzahl, welcher die Restklasse repräsentiert.
 Der zweite Parameter ist der Identifikator für die zweistellige Wertetabelle,
 welcher auch als Ganzzahl modelliert ist.
 Der letzte ist schliesslichen das vermeindlich neutrale Element, für das
 diese Funktion prüft, ob es wirklich das neutrale Element ist.
 In der zweiten Zeile wird durch alle Elemente der Restklasse iteriert,
 wodurch die Variable a den Wert jedes Elementes einmal annimmt (beginnend
 bei 0).
 In der dritten Zeile wird die Funktion map2d aufgerufen, welche das Element
 a (also jedes Element der Restklasse einmal) mit dem neutralen Element
 e verknüpft.
 Diese Funktion map2d funktioniert nach unserem eigents erfundenen Algorithmus,
 den wir im Kapitel '
\begin_inset CommandInset ref
LatexCommand nameref
reference "sub:Generieren-von-Gruppen"

\end_inset

' beschrieben haben.
 Der Rückgabewert dieser Funktion wird der Variable b zugewiesen um in der
 nächsten Zeile mit der Variable a verglichen zu werden.
 Wenn diese Bedingung zutrifft, bedeutet das, dass 
\begin_inset Formula $a\diamond e=e$
\end_inset

 gilt, also ist das e schonmal linksneutral.
 Wenn es nicht linksneutral ist, dann wir die ganze Funktion sofort abgebrochen,
 weil das Prädikat einen Allquantor beinhaltet - es muss also für alle Elemente
 gelten.
 Auf den folgenden Zeilen fünf und sechs wird die Variable a nochmals mit
 dem vermeindlich neutralen Element verknüft - diesmal aber um die Rechtsneutral
ität zu überprüfen (deshalb sind hier die Parameter a und e für die Funktion
 map2d vertauscht).
 Wenn sämtliche Elemente dieser Restklasse links- und rechtsneutral sind,
 dann wird die Schleife verlassen und die Funktion gerät zur Zeile acht,
 wo der boolsche Wert 'wahr' zurückgegeben wird.
 Dies bedeutet, dass das Element e tatsächlich das neutrale Element in dieser
 Struktur ist.
\end_layout

\begin_layout Subsection
Map und Reduce Funktionen für das Finden von Gruppen und Prüfen von Sätzen
\end_layout

\begin_layout Subsubsection
Prüfen derAxiome als Map-Funktion
\end_layout

\begin_layout Standard
Das CPU-intensive Suchen generieren der Strukturen, welche möglicherweise
 die Axiome erfüllen, wurde als MAP-Funktion definiert.
 
\end_layout

\begin_layout Standard
der Axiome wurde als MAP-Funktion definiert.
 Dabei werden den einzelnen Workern jeweils ein Bereich an Permutationen
 der Additionstabelle und ein 
\begin_inset Formula $n$
\end_inset

 im Sinne der derzeit vorhandenen Anzahl an verschiedenen Objekten als Input
 gegeben.
 Die Worker führen dann die Überprüfung der Axiome durch indem sie jeweils
 für alle Additionstabellen in ihrem Bereich alle möglichen Inversentabellen
 mit allen möglichen neutralen Elementen prüfen.
\end_layout

\begin_layout Standard
Hierbei gibt es Vereinfachungen, die inhaltlich korrekt sind jedoch die
 benötigte Rechenleistungen massiv reduzieren:
\end_layout

\begin_layout Itemize
Sowohl die Additions- wie auch die Permutationstabelle werden nicht immer
 vollständig vor der Prüfung der Axiome aufgestellt, sondern es wird eine
 Funktion implementiert mit der zu einer gegebenen Permutationsnummer eines
 beliebigen 
\begin_inset Formula $n$
\end_inset

 das Ergebnis für ein bestimmtes Element zurückgibt.
 Das heisst der Rechenaufwand wird substantiell reduziert da bei einer Prüfung
 der Axiome im Normalfall nur ein quasi vernachlässigbarer Teil der Additionstab
elle und, abhängig von Erfolg oder Misserfolg der Überprüfungen, auch nur
 ein minimer Teil der Inversentabelle benötigt wird.
\end_layout

\begin_layout Itemize
Für eine gegebene Additions- und Inversen-Tabellenkombination wird jeweils
 nur das neutrale Element, das für den ersten Eintrag in der Inversentabelle
 berechnet wurde, geprüft.
 Da logischerweise nur ein neutrales Element für eine spezifische Kombination
 aus Tabellen existiert, kann das Ergebnis der ersten Rechnung verwendet
 werden, da dieses bereits alle anderen möglichen neutralen Elemente wiederlegt.
 Auch diese Annahme reduziert substantiell die durchgeführten, nicht zielführend
en Rechnungen.
\end_layout

\begin_layout Standard
Die Ausgabe der Map-Funktion sind schlussendlich alle Gruppen auf die die
 gegebenen Axiome zutreffen.
 Eine Gruppe wird ausreichend durch 3 Zahlen beschrieben:
\end_layout

\begin_layout Itemize
Die Nummer der Additionstabelle.
 Aus Ihr lassen sich mit der oben beschriebenen Funktion alle Additionen,
 die in der Gruppe möglich sind, herleiten.
\end_layout

\begin_layout Itemize
Die Nummer der Inversentabelle.
 Aus Ihr lassen sich mit der oben beschriebenen Funktion die Inversen zu
 allen Elementen der Gruppe herleiten
\end_layout

\begin_layout Itemize
Das neutrale Element der Gruppe
\end_layout

\begin_layout Standard
Diese effiziente Speicherung ermöglicht das Vorhalten von enorm vielen Gruppen
 ohne einen hohen Speicherbedarf.
\end_layout

\begin_layout Subsubsection
Prüfen der Sätze als Reduce-Funktion
\end_layout

\begin_layout Standard
In der Reduce-Phase wird für die, relativ zur Menge der möglichen Gruppen,
 enorm kleine Menge an effektiven Gruppen der Satz jeweils geprüft.
 Als Output gibt sie die Gruppen für die der Satz nicht zutrifft.
 Da anzunehmen ist, dass somit der Output immer leer ist, kann er auch als
 booleanscher Wahrheitswert interpretiert werden:
\end_layout

\begin_layout Itemize
Wenn der Output leer ist, ist der Satz für die geprüften Gruppen wahr.
\end_layout

\begin_layout Itemize
Wenn der Output nicht leer ist, ist der Satz für die geprüften Gruppen falsch
 (was einer mathematischen Sensation gleich käme).
\end_layout

\begin_layout Section
Weiteres Vorgehen
\end_layout

\begin_layout Subsection
Möglichkeiten der Vertiefung der Aufgabenstellung
\begin_inset CommandInset label
LatexCommand label
name "sub:Möglichkeiten-der-Vertiefung"

\end_inset


\end_layout

\begin_layout Subsubsection
\noindent
Erweiterung des MapReduce Frameworks
\end_layout

\begin_layout Standard
\noindent
Bei diesem Schwerpunkt wäre die Zielsetzung eine möglichst grosse Kapazität
 Gültigkeiten zu beweisen mit dem MapReduce Framework und verteiltem Rechnen
 zu erzielen.
 Die enormen Datenmengen, die bereits bei kleinen Eingabewerten entstehen
 sind auf einem einzelnen System quasi nicht zu bewältigen dabei ist primär
 die Rechenzeit relevant.
 Daher müssten Möglichkeiten gefunden werden um eine Menge an Inputwerten
 zu anderen Computern zu senden, dort berechnen zu lassen und für das weitere
 Vorgehen relevante Daten zu returnieren.
\end_layout

\begin_layout Standard

\emph on
Anforderungen bei diesem Schwerpunkt wären primär die Handhabung von verteilten
 Systemen, Design der Applikation und eine performante Umsetzung.
\end_layout

\begin_layout Subsubsection
Freie Eingabe von auf Gültigkeit zu prüfenden Annahmen
\end_layout

\begin_layout Standard
\paragraph_spacing single
\noindent
Hierbei läge das Hauptaugenmerk darauf quasi eine Eingabesprache für ein
 automatisiertes Gültigkeitsbeweis-Programm zu erstellen.
 Es müsste eine Möglichkeit gefunden werden dem Programm mathematische Strukture
n mit bestimmten Eigenschaften, darauf gültige Axiome und daraus resultierend
 zu prüfende Sätze zu übermitteln.
 Dabei müsste, gleich ob interaktiv oder durch die Auswertung von Eingabedateien
, eine Eingabesyntax definiert werden und, was wohl die wirkliche Problemstellun
g des Schwerpunktes wäre, eine Auflösung der Syntax und eine darauf basierende
 dynamische Umsezuung in ausführbaren Code.
\end_layout

\begin_layout Standard

\emph on
Anforderungen bei diesem Schwerpunkt lägen primär in der theoretischen Informati
k beim Thema Compilerbau sowie der dynamischen Generierung einer Interpretation
 der Mathematischen Objekte, ihrem Einbinden und dem Ausführen in einer
 Applikation zur schlussendlichen Gültigkeitsprüfung.
\end_layout

\begin_layout Subsubsection
\noindent
Automatisierte Beweisbarkeit
\end_layout

\begin_layout Standard
\noindent
In diesem Fall wäre das Ziel ein Framework zu erstellen welches mit einem
 gegebenen Set aus mathematischen Operationen (zugelassenen Schlussregeln)
 automatisch Sätze aus Eingaben (Sätzen und Axiomen) herleitet.
 Die Operationen, die das System vornehmen könnten entsprächen den im Kalkül
 zugelassenen Schlussregeln.
 Ziel wäre es somit automatisiert mehr oder weniger sinnvolle Aussagen mathemati
sch formell korrekt herzuleiten.
 Dabei müssten Kriterien definiert werden mit denen die Unterscheidung von
 formal korrekten aber irrelevanten und formal korrekten, relevanten Aussagen
 möglich macht.
\end_layout

\begin_layout Standard

\emph on
Anforderungen bei diesem Schwerpunkt wäre wieder die Interpretation der
 in einer gegebenen Syntax vorliegenden Eingaben jedoch des weiteren das
 Erkennen von neuen relevanten Schlussfolgerungen.
 
\end_layout

\begin_layout Subsection
Entscheidung
\end_layout

\begin_layout Standard
Der auf Anhieb spannendste Schwerpunkt stellte nach der ersten Bertrachtung
 die 
\begin_inset Quotes pld
\end_inset

Freie Eingabe von auf Gültigkeit zu prüfenden Annahmen
\begin_inset Quotes prd
\end_inset

 dar.
 Die in dem Schwerpunkt vorkommenden Themen wurdenweitestgehend im bisherigen
 Studium noch nicht behandelt und böten somit eine gute Möglichkeit neues
 kennenzulernen.
 
\end_layout

\begin_layout Standard
Die Automatisierte Beweisbarkeit erschien bereits bei der ersten Betrachtung
 als eine eher unwahrscheinliche Vertiefung, da der schlussendliche Nutzen
 massiv in Frage gestellt werdern kann.
 Es wäre zu befürchten, dass eine enorme Menge an Arbeitszeit und Herzblut
 investiert würde um Schlussendlich eine Applikation zu erstellen welche
 Mathematisch völlig irrelevante Sätze herleiten würde.
 
\end_layout

\begin_layout Standard
Eine Erweiterung des MapReduce Framework erschien bereits nach der ersten
 Analyse als überschaubares Problem im Sinne der Beherrschbarkeit der Problemste
llung.
 Zwar ist der mit der Vertiefung verbundene Aufand alles andere als als
 klein zu erachten, jedoch sollten keine vollkommen unvorhergesehenen Fragestell
ungen, zu denen ohne eine sehr grosse Menge an Vertiefung keine Lösung gefunden
 werden könnte, auftreten.
\end_layout

\begin_layout Standard
Das Kriterium der Beherrschbarkeit gab schlussendlich auch den Ausschlag
 anstatt der Vertiefung Nr.
 2 eine Erweiterung des Frameworkes anzustreben.
 Die Gefahr durch die enorme Komplexität am Ende nur eine mehr prototypisch
 als sinnvolle Implementation eines Programmes zu erstellen schreckte uns
 ab.
 Desweiteren stellte die Idee mit der gegebenen Infrastruktur der Fachhochschule
 eventuell eine grosse Menge an PCs für einen Feldversuch zu besitzen einen
 grossen Ansporn dar.
\end_layout

\begin_layout Section
Umsetzung - Teil 2 MapReduce Framework zur verteilten Berechnung
\end_layout

\begin_layout Subsection
Master als zentrale Kontrollinstanz
\end_layout

\begin_layout Standard
Der Master ist ein Server, welcher die Aufgaben (Tasks) und Worker verwaltet.
 Ein Task ist eine abstrakte Einheit, welche von einem Worker erledigt werden
 kann, also entweder ein Teil einer Map- oder Reduce-Berechnung.
 Im klassischen MapReduce, wie es von Google beschrieben wurde, ist ein
 Worker eine Maschine.
 Somit verteilt eine Hauptmaschine (Master) die verschiedenen Aufgaben an
 verschiedene Rechner in einem Netzwerk.
 In unserer Implementation ist aber ein Worker nicht zwingend eine anderen
 Maschine, sondern wir haben diese Einheit abstrahiert.
 In der ersten Version unseres Frameworks gab es nur eine Art von Workern
 - Threads - aber mittlerweile kann via Plugin irgendeine Art von Worker
 dem Master übergeben werden.
 Die konkrete Verwaltung wird dabei vom Pool übernommen, welcher den Status
 der Worker kennt (z.B.
 beschäftigt, frei, unauffindbar, etc) und weiss, welche Tasks gerade zu
 erledigen sind.Ein Plugin ist Stück Code, welches eine Worker-Technologie
 zur Verfügung stellt.
 Somit gibt es also zum Beispiel ein Plugin, welches Threads als Worker
 zur Verfügung stellt und ein Plugin, welches andere Rechner über eine Socket-Ve
rbindung zur Verfügung stellt.
 Dies wurde so abstrahiert, dass in Zukunft auch weitere Arten von Workern
 hinzugeügt werden können.
 Denkbar wäre zum Beispiel CUDA (NVidia Grafikkarten) oder Android Smartphones.
\end_layout

\begin_layout Subsection
Ablauf
\end_layout

\begin_layout Standard
Wenn eine Berechnung mit dem MapReduce Framework ausgeführt werden soll,
 ist der Ablauf folgendermassen (vereinfacht): Der Benutzer implementiert
 die beiden Interfaces MapInstruction und ReduceInstruction (sowie optional
 eine CombinerInstruction, aber diese soll zur Vereinfachung weggelassen
 werden) und erstellt zusammen mit einer Menge an Input einen MapReduceTask.
 Dieser MapReduceTask ist die ursprüngliche Berechnungseinheit, welche dem
 Master zur Berechnung übergeben wird.Daraus kann dann der Master die Map-
 und Reduce Instruktionen extrahieren und erstellt zunächst aus je einem
 Teil vom Input und einer Instanz der MapInstruction einen MapTask.
 Somit entstehen für eine MapReduce Berechnung mehrere MapTasks, welche
 dem Pool vom Master zur Verarbeitung übergeben werden.
 Gleichzeitig wird vorausgesetzt, dass dem Pool durch ein oder mehrere Plugins
 bereits Worker zur Verfügung gestellt worden sind (donaten).
 Somit kann der Pool einen auszuführenden MapTask einem verfügbaren Worker
 übergeben.
 Wenn dieser Worker eine andere Maschine im Netz abstrahiert, würde das
 bedeuten, dass dieser MapTask auf einem anderen Rechner ausgeführt wird.Um
 diesen Task auszuführen, muss ein Kontext erstellt werden, in welchem der
 Task ausgeführt werden kann, denn ein Task (Map sowie Reduce) arbeitet
 jeweils gegen ein Emitter, in welchem die Zwischenresultate abgespeichert
 werden können.
 Aus der Sicht einer Instruktion (Map sowie Reduce) ist es also transparent,
 wo sie ausgeführt wird.
 Sie muss lediglich in den Kontext emitten.Sobald die Berechnung (z.B.
 auf einem anderen Rechner) ausgeführt wurde, meldet sich der Worker wieder
 beim Pool, dass er wieder bereit ist, Aufgaben anzunehmen.
 Also könnte eine ganze Berechnung entweder von einem einzelnen Worker in
 mehreren Schritten ausgeführt werden oder auf mehrere Worker aufgeteilt,
 je nach dem wie schnell ein einzelner ist.
 Gleichzeitig prüft der Master kontinuierlich, ob alle MapTasks ausgeführt
 worden sind.Sobald alle MapTasks für eine Berechnung ausgeführt worden sind,
 beginnt der Master alle Resultate zu sammeln und schliesst somit die Map-Phase
 ab.
 Darauf folgt die Combiner-Phase, in welcher die Resultate der Map-Phase
 nach Schlüssel gruppiert werden und somit auf die Reduce-Phase vorbereitet.
 Da vor der Shuffle-Phase alle MapTasks ausgeführt werden sein müssen, gilt
 dies als Bottleneck von MapReduce.Nach der Shuffle-Phase beginnt der Master
 damit die einzelnen ReduceTasks, bestehend aus einer Instanz der ReduceInstruct
ion und einem Teil der Shuffle Resultate, zu erstellen und diese wieder
 dem Pool zu übergeben.
 Dann beginnt der Pool wieder diese ReduceTasks den verfügbaren Worker zuzuteile
n und der Master wartet wiederum auf deren Fertigstellung.
 Sobald auch diese fertig sind, ist die ganze MapReduce Berechnung fertig.
\end_layout

\begin_layout Subsection
Ablauf bei verteilter Berechnung
\end_layout

\begin_layout Standard
Für das Ausführen von verteilen Berechnungen haben wir das Framework SIMON
\begin_inset Foot
status open

\begin_layout Plain Layout
http://dev.root1.de/projects/simon
\end_layout

\end_inset

 verwendet.
 Mit Hilfe dieses Frameworks können Methoden auf einer entfernten Instanz
 irgendwo im Netzwerk gemacht werden.
 Damit sich der Master nicht um die Komplexitäten im Zusammenhang mit Remote
 Procedure Call (RPC) kümmern muss, wird ein einzelner Client, also eine
 entfernte Instanz, auf dem Server genauso wie ein gewöhnlicher Thread als
 Worker im Pool registriert.
 Die konkrete Implementation dieses Workers ruft aber, anstatt den Task
 direkt auszuführen, via RPC eine Methode auf dem Client auf und übermittelt
 im die Instruktion mit zugehörigen Eingabewerten.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Client Server Interaction.png

\end_inset


\end_layout

\begin_layout Standard
Auf dem Client wartet ein sogenannter SocketAgent ständig darauf, dass er
 Tasks vom Server zugeordnet bekommt.
 Sobald ein Task angekommen ist, wird dieser ausgeführt und die Resultate
 werden wieder an den SocketWorker geschickt, welcher auf dem Server ist.
 Der SocketWorker kümmert sich dann um das korrekte Speichern der Resultate
 und meldet dem Pool, dass er wieder Arbeit aufnehmen kann.
\end_layout

\end_body
\end_document
