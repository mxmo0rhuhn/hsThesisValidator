#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language german-ch
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language polish
\papercolumns 1
\papersides 1
\paperpagestyle default
\bullet 0 0 0 -1
\bullet 1 0 8 -1
\bullet 2 0 9 -1
\bullet 3 0 6 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Softwareprojekt II - 
\begin_inset Quotes pld
\end_inset

Untersuchung zu den Begriffen Gültigkeit und Beweisbarkeit in einer mathematisch
en Theorie
\begin_inset Quotes prd
\end_inset


\end_layout

\begin_layout Author
Reto Hablützel, Max Schrimpf
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Einleitung
\end_layout

\begin_layout Subsection
Aufgabenstellung
\end_layout

\begin_layout Quote
Es soll augehend von einem gegebenen einfachen Axiomensystem (z.B “Gruppe”)
 ein einfacher Satz einereits bewiesen werden und anderseits seine “Gültigkeit”
 illustriert werden.
 Ein Beweis soll entlang von gegebenen formalisierten Schlussregeln erfolgen,
 von der Gültigkeit soll man sich mittels “durchrechnen” überzeugen, bei
 unendlichen Strukturen mit einer zufallsgenerierten Auswahl von Fällen..
 
\end_layout

\begin_layout Standard
Ausgehend von dieser vorgegebenen Aufgabenstellung soll in dieser Projektarbeit
 eine Implementation erarbeitet werden mit der geforderten Fähigkeit die
 Gültigkeit eines Axiomsystemes in den Grundsätzen zu bewisen.
 Durch das Enorme Wachstum der Ausgangswerte 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Wie genau es wächst wär hier halt schon noch spannend...
\end_layout

\end_inset

sind dabei schon relativ kleine Systeme mit bedeutendem Rechenaufwand verbunden.
 Die genaue Schwerpunktsetzung bei der Umsetzung und das Vorgehen war dabei
 durch die offene Aufgabenstellung dem Projektteam überlassen.
 Vorgegeben war mur die Implementation eines automatisierten Gültigkeitsbeweises
 des Satzes zur Rechtsauslöschung in Gruppen.
\end_layout

\begin_layout Subsection
Ausgangslage
\end_layout

\begin_layout Subsubsection
MapReduce
\end_layout

\begin_layout Standard
MapReduce ist ein Framework, welches die parallele Verarbeitung grosser
 Datenmengen vereinfachen soll und erstmals von Google beschrieben und implement
iert wurde.
 Google war mit dem Problem konfrontiert, dass sie sehr grossen Datenmengen
 verarbeiten mussten.
 Um ein Programm so zu schreiben, dass es auf einer verteilten Architektur
 gut skaliert, muss sehr schnell viel Code geschrieben werden, der nichts
 mit dem eigentlichen Problem zu tun hat.
 Deshalb hat Google ein Framework entwickelt, welches es dem Benutzer erlaubt
 sein Problem in zwei Phasen zu definieren und der Rest wird vom Framework
 übernommen.
 Dabei kümmert sich das Framework zum Beispiel darum, was passiert, wenn
 eine Maschine im ausfällt oder wie die einzelnen Arbeittsschritte auf die
 verschiedenen Maschinen aufgeteilt werden.
\end_layout

\begin_layout Standard
Die zwei Phasen sind, wie der Name suggeriert, Map und Reduce (und eine
 optionale Combiner Phase, aber diese ist zum Verständnis unwichtig).
 In diesen Phasen werden im Wesentlichen die beiden Funktionen Map und Reduce
 aufgerufen, welche hier kurz erklärt werden sollen.
\end_layout

\begin_layout Standard
\begin_inset Foot
status open

\begin_layout Plain Layout
Schreibweise: a ist ein Element aus einer Menge A
\end_layout

\end_inset


\begin_inset Formula $map:(a\rightarrow b)\rightarrow A\rightarrow B$
\end_inset


\end_layout

\begin_layout Standard
Die Map Funktion bildet eine Menge von Elementen elementweise auf eine neue
 Menge ab.
 Dazu muss ihr zwei Parameter übergeben werden – eine Funktion, welche eine
 Element aus der Menge A auf ein Element in der Menge B abbildet und eine
 Menge von Elementen A.
 Dann wird die Funktion sukzessive auf die Elemente der Liste A angewendet
 und somit die Menge B konstruiert, welche das Resultat ist.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $reduce:(b\rightarrow c\rightarrow c)\rightarrow c\rightarrow B\rightarrow c$
\end_inset


\end_layout

\begin_layout Standard
Die Reduce Funktion bildet eine Menge B auf einen einzelnen Wert ab.
 Dafür nimmt sie als ersten Parameter eine Funktion, welche einen Wert aus
 der Menge B und einen Akkumulator als Parameter nimmt und einen Wert b
 zurückgibt.
 Der zweite Parameter der Reduce Funktion ist der initiale Wert für den
 Akkumulator und der dritte ist die Menge B.
 Dann wird die übergebene Funktion mit jedem Element aus der Menge B und
 dem Akkumulator aufgerufen.
 Dabei ist das Resulat der Funktion jeweils der neue Wert für den Akkumulator.
 Sobald die ganze Liste traversiert wurde, ist der Wert vom Akkumulator
 das Resultat.
\end_layout

\begin_layout Standard
Der Benutzer vom MapReduce Framework, welches etwas berechnen will, muss
 also eine Funktion schrieben, welche ein Element aus der Menge A auf ein
 Element in der Menge B abbildet (Map Phase) und die Menge A bereitstellen.
 Ausserdem muss eine Funktion geschrieben werden, welche für ein Element
 aus der Menge B kombiniert mit einem Akkumulator auf ein Element aus der
 Menge C abbildet (Reduce Phase).
 Das MapReduce Framework kann dann zum Beispiel die erste Funktion mit einem
 Element aus der Menge A zusammen an eine Maschine schicken.
 Wie die Grafik
\begin_inset Note Note
status open

\begin_layout Plain Layout
muss noch gezeichnet werden..
\end_layout

\end_inset

 zur Map Funktion illustriert, gibt es keine Datenabhängigkeiten (1:1 Mapping),
 weshalb jede Funktionsanwendung sehr gut auf verschiedenen Maschinen ausgeführt
 werden kann.
 Die Map Phase gilt als abgeschlossen, wenn sämtliche Elemente aus der Menge
 A auf ein Element in der Menge B abgebildet wurden.
 Dann kann das MapReduce Framework auf einer Maschine die Reduce-Phase durchführ
en.
 Hierbei ist wichtig zu bemerken, dass die Reduce Funktion nicht ganz so
 optimal parallelisiert werden dann, da es Datenabhängigkeiten gibt.
 Eine parallele Verarbeitung ist nur möglich, wenn die Reduce Funktion assoziati
v ist.
 Dann könnte die Reduce-Phase in einer Art Baum-Struktur ausgeführt werden
 – darauf soll aber nicht weiter eingegangen werden.
\end_layout

\begin_layout Standard
Folgendendes Beispiel soll die Idee von den zwei Phasen verdeutlichen.
 Dafür definieren wir ein initiale Menge an Elementen A und je eine Funktion
 für die Map Phase 
\begin_inset Formula $f_{m}$
\end_inset

 und eine Funktion für die Reduce Phase 
\begin_inset Formula $f_{r}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $A={1,2,3,4}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $f_{m}\: x=x^{2}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $f_{r}\: x\: a=x+a$
\end_inset


\end_layout

\begin_layout Standard
In diesem Beispiel werden in der Map Phase die Elemente aus der Menge A
 quadriert.
 Somit entsteht eine Menge B = {1, 4, 9, 16}.
 In der Reduce Phase werden alle Elemente aus der Menge B aufaddiert
\begin_inset Foot
status open

\begin_layout Plain Layout
Der initiale Akkumulator ist in diesem Fall das erste Element aus der Menge
 B.
\end_layout

\end_inset

.
 Das Endresultat ist also 30.
\end_layout

\begin_layout Section
Umsetzung - Teil 1 Gültigkeit des Satzes zur Rechtsauslöschung in Gruppen
\end_layout

\begin_layout Subsection
Map und der Reduce Funktion für die Aufgabenstellung
\end_layout

\begin_layout Subsubsection
Prüfen derAxiome als Map Funktion
\end_layout

\begin_layout Standard
Das CPU-intensive Prüfen der Axiome wurde als MAP-Funktion definiert.
 Dabei werden den einzelnen Workern jeweils ein Bereich an Permutationen
 und ein n als Input gegeben und sie liefern alle gefundenen 
\end_layout

\begin_layout Section
Weiteres Vorgehen
\end_layout

\begin_layout Subsection
Möglichkeiten der Vertiefung der Aufgabenstellung
\end_layout

\begin_layout Subsubsection
\noindent
Erweiterung des MapReduce Frameworks
\end_layout

\begin_layout Standard
\noindent
Bei diesem Schwerpunkt wäre die Zielsetzung eine möglichst grosse Kapazität
 Gültigkeiten zu beweisen mit dem MapReduce Framework und verteiltem Rechnen
 zu erzielen.
 Die enormen Datenmengen, die bereits bei kleinen Eingabewerten entstehen
 sind auf einem einzelnen System quasi nicht zu bewältigen dabei ist primär
 die Rechenzeit relevant.
 Daher müssten Möglichkeiten gefunden werden um eine Menge an Inputwerten
 zu anderen Computern zu senden, dort berechnen zu lassen und für das weitere
 Vorgehen relevante Daten zu returnieren.
\end_layout

\begin_layout Standard

\emph on
Anforderungen bei diesem Schwerpunkt wären primär die Handhabung von verteilten
 Systemen, Design der Applikation und eine performante Umsetzung.
\end_layout

\begin_layout Subsubsection
Freie Eingabe von auf Gültigkeit zu prüfenden Annahmen
\end_layout

\begin_layout Standard
\paragraph_spacing single
\noindent
Hierbei läge das Hauptaugenmerk darauf quasi eine Eingabesprache für ein
 automatisiertes Gültigkeitsbeweis-Programm zu erstellen.
 Es müsste eine Möglichkeit gefunden werden dem Programm mathematische Strukture
n mit bestimmten Eigenschaften, darauf gültige Axiome und daraus resultierend
 zu prüfende Sätze zu übermitteln.
 Dabei müsste, gleich ob interaktiv oder durch die Auswertung von Eingabedateien
, eine Eingabesyntax definiert werden und, was wohl die wirkliche Problemstellun
g des Schwerpunktes wäre, eine Auflösung der Syntax und eine darauf basierende
 dynamische Umsezuung in ausführbaren Code.
\end_layout

\begin_layout Standard

\emph on
Anforderungen bei diesem Schwerpunkt lägen primär in der theoretischen Informati
k beim Thema Compilerbau sowie der dynamischen Generierung einer Interpretation
 der Mathematischen Objekte, ihrem Einbinden und dem Ausführen in einer
 Applikation zur schlussendlichen Gültigkeitsprüfung.
\end_layout

\begin_layout Subsubsection
\noindent
Automatisierte Beweisbarkeit
\end_layout

\begin_layout Standard
\noindent
In diesem Fall wäre das Ziel ein Framework zu erstellen welches mit einem
 gegebenen Set aus mathematischen Operationen (zugelassenen Schlussregeln)
 automatisch Sätze aus Eingaben (Sätzen und Axiomen) herleitet.
 Die Operationen, die das System vornehmen könnten entsprächen den im Kalkül
 zugelassenen Schlussregeln.
 Ziel wäre es somit automatisiert mehr oder weniger sinnvolle Aussagen mathemati
sch formell korrekt herzuleiten.
 Dabei müssten Kriterien definiert werden mit denen die Unterscheidung von
 formal korrekten aber irrelevanten und formal korrekten, relevanten Aussagen
 möglich macht.
\end_layout

\begin_layout Standard

\emph on
Anforderungen bei diesem Schwerpunkt wäre wieder die Interpretation der
 in einer gegebenen Syntax vorliegenden Eingaben jedoch des weiteren das
 Erkennen von neuen relevanten Schlussfolgerungen.
 
\end_layout

\begin_layout Subsection
Entscheidung
\end_layout

\begin_layout Standard
Der auf Anhieb spannendste Schwerpunkt stellte nach der ersten Bertrachtung
 die 
\begin_inset Quotes pld
\end_inset

Freie Eingabe von auf Gültigkeit zu prüfenden Annahmen
\begin_inset Quotes prd
\end_inset

 dar.
 Die in dem Schwerpunkt vorkommenden Themen wurdenweitestgehend im bisherigen
 Studium noch nicht behandelt und böten somit eine gute Möglichkeit neues
 kennenzulernen.
 
\end_layout

\begin_layout Standard
Die Automatisierte Beweisbarkeit erschien bereits bei der ersten Betrachtung
 als eine eher unwahrscheinliche Vertiefung, da der schlussendliche Nutzen
 massiv in Frage gestellt werdern kann.
 Es wäre zu befürchten, dass eine enorme Menge an Arbeitszeit und Herzblut
 investiert würde um Schlussendlich eine Applikation zu erstellen welche
 Mathematisch völlig irrelevante Sätze herleiten würde.
 
\end_layout

\begin_layout Standard
Eine Erweiterung des MapReduce Framework erschien bereits nach der ersten
 Analyse als überschaubares Problem im Sinne der Beherrschbarkeit der Problemste
llung.
 Zwar ist der mit der Vertiefung verbundene Aufand alles andere als als
 klein zu erachten, jedoch sollten keine vollkommen unvorhergesehenen Fragestell
ungen, zu denen ohne eine sehr grosse Menge an Vertiefung keine Lösung gefunden
 werden könnte, auftreten.
\end_layout

\begin_layout Standard
Das Kriterium der Beherrschbarkeit gab schlussendlich auch den Ausschlag
 anstatt der Vertiefung Nr.
 2 eine Erweiterung des Frameworkes anzustreben.
 Die Gefahr durch die enorme Komplexität am Ende nur eine mehr prototypisch
 als sinnvolle Implementation eines Programmes zu erstellen schreckte uns
 ab.
 Desweiteren stellte die Idee mit der gegebenen Infrastruktur der Fachhochschule
 eventuell eine grosse Menge an PCs für einen Feldversuch zu besitzen einen
 grossen Ansporn dar.
\end_layout

\end_body
\end_document
